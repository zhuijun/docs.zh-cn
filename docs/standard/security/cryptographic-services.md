---
title: 加密服务
description: .NET 支持的加密方法和实践的概述。
ms.date: 07/14/2020
ms.technology: dotnet-standard
helpviewer_keywords:
- cryptography [.NET]
- pattern of derived class inheritance
- digital signatures
- asymmetric cryptographic algorithms
- digital signatures, public-key systems
- public keys
- decryption [.NET]
- private keys
- MAC algorithms
- cryptographic algorithms
- private keys, overview
- encryption [.NET]
- security [.NET], encryption
- cryptographic services
- symmetric cryptographic algorithms
- hash
- message authentication codes
- derived class inheritance
- cryptography [.NET], about
- random number generation
ms.assetid: f96284bc-7b73-44b5-ac59-fac613ad09f8
ms.openlocfilehash: 651231dcc41926307e3a46b67c80ba3df1fb25e9
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90549975"
---
# <a name="cryptographic-services"></a><span data-ttu-id="dbb4c-103">加密服务</span><span class="sxs-lookup"><span data-stu-id="dbb4c-103">Cryptographic Services</span></span>

<span data-ttu-id="dbb4c-104">公共网络（如 Internet）不提供实体之间安全通信的方式。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-104">Public networks such as the Internet do not provide a means of secure communication between entities.</span></span> <span data-ttu-id="dbb4c-105">此类网络上的通信易被读取或甚至被未经授权的第三方修改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-105">Communication over such networks is susceptible to being read or even modified by unauthorized third parties.</span></span> <span data-ttu-id="dbb4c-106">加密有助于防止数据被查看，提供检测数据是否已修改的方法，并帮助提供一种跨不安全通道安全通信的方式。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-106">Cryptography helps protect data from being viewed, provides ways to detect whether data has been modified, and helps provide a secure means of communication over otherwise nonsecure channels.</span></span> <span data-ttu-id="dbb4c-107">例如，数据可通过使用加密算法进行加密、以加密状态进行传输并在稍后由预期方进行解密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-107">For example, data can be encrypted by using a cryptographic algorithm, transmitted in an encrypted state, and later decrypted by the intended party.</span></span> <span data-ttu-id="dbb4c-108">如果某个第三方截获了加密数据，将很难解密此数据。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-108">If a third party intercepts the encrypted data, it will be difficult to decipher.</span></span>

<span data-ttu-id="dbb4c-109">在 .NET 中，命名空间中的类 <xref:System.Security.Cryptography> 可管理很多有关加密的详细信息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-109">In .NET, the classes in the <xref:System.Security.Cryptography> namespace manage many details of cryptography for you.</span></span> <span data-ttu-id="dbb4c-110">有些是操作系统实现的包装器，而另一些则是纯托管实现。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-110">Some are wrappers for operating system implementations, while others are purely managed implementations.</span></span> <span data-ttu-id="dbb4c-111">无需是加密方面的专家，即可使用这些类。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-111">You do not need to be an expert in cryptography to use these classes.</span></span> <span data-ttu-id="dbb4c-112">在创建其中一个加密算法类的新实例时，为易于使用，将自动生成密钥，并且默认属性将尽可能地安全可靠。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-112">When you create a new instance of one of the encryption algorithm classes, keys are autogenerated for ease of use, and default properties are as safe and secure as possible.</span></span>

<span data-ttu-id="dbb4c-113">本概述提供 .NET 支持的加密方法和惯例的概要，包括 ClickOnce 清单。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-113">This overview provides a synopsis of the encryption methods and practices supported by .NET, including the ClickOnce manifests.</span></span>

## <a name="cryptographic-primitives"></a><span data-ttu-id="dbb4c-114">加密基元</span><span class="sxs-lookup"><span data-stu-id="dbb4c-114">Cryptographic Primitives</span></span>

<span data-ttu-id="dbb4c-115">在使用加密的典型情况下，两方（Alice 和 Bob）均通过非安全通道进行通信。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-115">In a typical situation where cryptography is used, two parties (Alice and Bob) communicate over a nonsecure channel.</span></span> <span data-ttu-id="dbb4c-116">Alice 和 Bob 想要确保其通信不可为任何可能正在侦听的人理解。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-116">Alice and Bob want to ensure that their communication remains incomprehensible by anyone who might be listening.</span></span> <span data-ttu-id="dbb4c-117">此外，由于 Alice 和 Bob 处于远程位置，所以 Alice 必须确保她从 Bob 处收到的信息在传输期间未被任何人修改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-117">Furthermore, because Alice and Bob are in remote locations, Alice must make sure that the information she receives from Bob has not been modified by anyone during transmission.</span></span> <span data-ttu-id="dbb4c-118">此外，她必须确保此信息确实来自 Bob 本人，而不是模仿 Bob 的人。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-118">In addition, she must make sure that the information really does originate from Bob and not from someone who is impersonating Bob.</span></span>

<span data-ttu-id="dbb4c-119">加密用于实现以下目标：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-119">Cryptography is used to achieve the following goals:</span></span>

- <span data-ttu-id="dbb4c-120">保密性：有助于防止用户的身份或数据被读取。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-120">Confidentiality: To help protect a user's identity or data from being read.</span></span>

- <span data-ttu-id="dbb4c-121">数据完整性：有助于防止数据被更改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-121">Data integrity: To help protect data from being changed.</span></span>

- <span data-ttu-id="dbb4c-122">身份验证：确保数据来自于特定方。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-122">Authentication: To ensure that data originates from a particular party.</span></span>

- <span data-ttu-id="dbb4c-123">不可否认性：防止特定方否认其发送过消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-123">Non-repudiation: To prevent a particular party from denying that they sent a message.</span></span>

<span data-ttu-id="dbb4c-124">若要实现这些目标，可以使用称为加密基元的算法和惯例的组合来创建加密方案。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-124">To achieve these goals, you can use a combination of algorithms and practices known as cryptographic primitives to create a cryptographic scheme.</span></span> <span data-ttu-id="dbb4c-125">下表列出了加密基元以及其用途。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-125">The following table lists the cryptographic primitives and their uses.</span></span>

|<span data-ttu-id="dbb4c-126">加密基元</span><span class="sxs-lookup"><span data-stu-id="dbb4c-126">Cryptographic primitive</span></span>|<span data-ttu-id="dbb4c-127">使用</span><span class="sxs-lookup"><span data-stu-id="dbb4c-127">Use</span></span>|
|-----------------------------|---------|
|<span data-ttu-id="dbb4c-128">私钥加密（对称加密）</span><span class="sxs-lookup"><span data-stu-id="dbb4c-128">Secret-key encryption (symmetric cryptography)</span></span>|<span data-ttu-id="dbb4c-129">在数据上执行转换，以防止其被第三方读取。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-129">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="dbb4c-130">此类型的加密使用单个共享的密钥来加密和解密数据。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-130">This type of encryption uses a single shared, secret key to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="dbb4c-131">公钥加密（非对称加密）</span><span class="sxs-lookup"><span data-stu-id="dbb4c-131">Public-key encryption (asymmetric cryptography)</span></span>|<span data-ttu-id="dbb4c-132">在数据上执行转换，以防止其被第三方读取。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-132">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="dbb4c-133">此类型的加密使用公钥/私钥对来加密和解密数据。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-133">This type of encryption uses a public/private key pair to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="dbb4c-134">加密签名</span><span class="sxs-lookup"><span data-stu-id="dbb4c-134">Cryptographic signing</span></span>|<span data-ttu-id="dbb4c-135">通过创建特定于参与方的数字签名，帮助验证数据是否来自此特定方。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-135">Helps verify that data originates from a specific party by creating a digital signature that is unique to that party.</span></span> <span data-ttu-id="dbb4c-136">此流程也使用哈希函数。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-136">This process also uses hash functions.</span></span>|
|<span data-ttu-id="dbb4c-137">加密哈希</span><span class="sxs-lookup"><span data-stu-id="dbb4c-137">Cryptographic hashes</span></span>|<span data-ttu-id="dbb4c-138">将任意长度的数据映射到固定长度的字节序列。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-138">Maps data from any length to a fixed-length byte sequence.</span></span> <span data-ttu-id="dbb4c-139">哈希值在统计上是唯一的；不同的双字节序列不会有哈希处理为同一个值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-139">Hashes are statistically unique; a different two-byte sequence will not hash to the same value.</span></span>|

## <a name="secret-key-encryption"></a><span data-ttu-id="dbb4c-140">私钥加密</span><span class="sxs-lookup"><span data-stu-id="dbb4c-140">Secret-Key Encryption</span></span>

<span data-ttu-id="dbb4c-141">密钥加密算法使用单个密钥来加密和解密数据。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-141">Secret-key encryption algorithms use a single secret key to encrypt and decrypt data.</span></span> <span data-ttu-id="dbb4c-142">必须确保密钥不被未经授权的代理访问，因为具有此密钥的任意方均可使用此密钥解密你的数据或者加密自己的数据，而声称此数据来自于你。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-142">You must secure the key from access by unauthorized agents, because any party that has the key can use it to decrypt your data or encrypt their own data, claiming it originated from you.</span></span>

<span data-ttu-id="dbb4c-143">密钥加密也称为对称加密，因为加密和解密所用的密码相同。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-143">Secret-key encryption is also referred to as symmetric encryption because the same key is used for encryption and decryption.</span></span> <span data-ttu-id="dbb4c-144">密钥加密算法非常迅速（相比于公钥算法），也非常适合在大型数据流上执行加密转换。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-144">Secret-key encryption algorithms are very fast (compared with public-key algorithms) and are well suited for performing cryptographic transformations on large streams of data.</span></span> <span data-ttu-id="dbb4c-145">非对称加密算法（例如 RSA）从数学上来说在可加密的数据量方面存在限制。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-145">Asymmetric encryption algorithms such as RSA are limited mathematically in how much data they can encrypt.</span></span> <span data-ttu-id="dbb4c-146">对称加密算法通常没有这些问题。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-146">Symmetric encryption algorithms do not generally have those problems.</span></span>

<span data-ttu-id="dbb4c-147">一种名为分组加密的密钥算法用于一次加密一个数据块。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-147">A type of secret-key algorithm called a block cipher is used to encrypt one block of data at a time.</span></span> <span data-ttu-id="dbb4c-148">分组加密（例如数据加密标准 (DES)、TripleDES 和高级加密标准 (AES)）可将 *n* 字节的输入块通过加密转换为由加密字节构成的输出块。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-148">Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of *n* bytes into an output block of encrypted bytes.</span></span> <span data-ttu-id="dbb4c-149">如果想要加密或解密字节序列，则必须逐块执行。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-149">If you want to encrypt or decrypt a sequence of bytes, you have to do it block by block.</span></span> <span data-ttu-id="dbb4c-150">由于 *n* 很小（DES 和 TripleDES 为 8 字节；AES 为 16 字节 [默认值]、24 字节或 32 字节），所以对于大于 *n* 的数据值，必须一次加密一个数据块。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-150">Because *n* is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than *n* have to be encrypted one block at a time.</span></span> <span data-ttu-id="dbb4c-151">小于 *n* 的数据值则必须扩展为 *n* 才能进行处理。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-151">Data values that are smaller than *n* have to be expanded to *n* in order to be processed.</span></span>

<span data-ttu-id="dbb4c-152">分组加密的一种简单形式被称为电子密码本 (ECB) 模式。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-152">One simple form of block cipher is called the electronic codebook (ECB) mode.</span></span> <span data-ttu-id="dbb4c-153">ECB 模式被视为不安全，因为它不使用初始化向量来初始化第一个纯文本块。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-153">ECB mode is not considered secure, because it does not use an initialization vector to initialize the first plaintext block.</span></span> <span data-ttu-id="dbb4c-154">对于给定的密钥 *k*，不使用初始化向量的简单分组加密会将相同的纯文本输入块加密为相同的已加密文本的输出块。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-154">For a given secret key *k*, a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext.</span></span> <span data-ttu-id="dbb4c-155">因此，如果输入的纯文本流中存在重复的块，则输出密码文本流中也会有重复的块。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-155">Therefore, if you have duplicate blocks in your input plaintext stream, you will have duplicate blocks in your output ciphertext stream.</span></span> <span data-ttu-id="dbb4c-156">这些重复的输出块会警告未经授权的用户使用了可能被采用的算法访问不可靠的加密以及可能的攻击模式。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-156">These duplicate output blocks alert unauthorized users to the weak encryption used the algorithms that might have been employed, and the possible modes of attack.</span></span> <span data-ttu-id="dbb4c-157">因此，ECB 密码模式非常易于分析，最终导致密钥易于被发现。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-157">The ECB cipher mode is therefore quite vulnerable to analysis, and ultimately, key discovery.</span></span>

<span data-ttu-id="dbb4c-158">基类库中提供的分组加密类使用称为加密块链接 (CBC) 的默认链接模式，但可随意更改此默认设置。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-158">The block cipher classes that are provided in the base class library use a default chaining mode called cipher-block chaining (CBC), although you can change this default if you want.</span></span>

<span data-ttu-id="dbb4c-159">通过使用初始化向量 (IV) 加密第一个纯文本块，CBC 密码克服了与 ECB 密码关联的问题。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-159">CBC ciphers overcome the problems associated with ECB ciphers by using an initialization vector (IV) to encrypt the first block of plaintext.</span></span> <span data-ttu-id="dbb4c-160">每个后续纯文本块在加密之前，都将与之前的密码文本块进行位异或 (`XOR`) 运算。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-160">Each subsequent block of plaintext undergoes a bitwise exclusive OR (`XOR`) operation with the previous ciphertext block before it is encrypted.</span></span> <span data-ttu-id="dbb4c-161">因此，每个密码文本块均依赖于之前所有的块。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-161">Each ciphertext block is therefore dependent on all previous blocks.</span></span> <span data-ttu-id="dbb4c-162">使用此系统时，可能已为未经授权的用户所知的常见消息头不可用来对密钥进行反向工程处理。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-162">When this system is used, common message headers that might be known to an unauthorized user cannot be used to reverse-engineer a key.</span></span>

<span data-ttu-id="dbb4c-163">一种泄露以 CBC 密码加密的数据的方式是对每个可能的密钥执行详尽搜索。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-163">One way to compromise data that is encrypted with a CBC cipher is to perform an exhaustive search of every possible key.</span></span> <span data-ttu-id="dbb4c-164">具体取决于用来执行加密的密钥大小，这种搜索即使是使用最快的计算机也非常耗时，因此不可行。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-164">Depending on the size of the key that is used to perform encryption, this kind of search is very time-consuming using even the fastest computers and is therefore infeasible.</span></span> <span data-ttu-id="dbb4c-165">密钥大小更大，解密更难。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-165">Larger key sizes are more difficult to decipher.</span></span> <span data-ttu-id="dbb4c-166">虽然从理论上来说，加密并未使攻击者检索加密数据变得不可能，但它确实增加了执行此操作的成本。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-166">Although encryption does not make it theoretically impossible for an adversary to retrieve the encrypted data, it does raise the cost of doing this.</span></span> <span data-ttu-id="dbb4c-167">如果花费三个月的时间执行详尽搜索来检索仅在几天之内有意义的数据，则详尽搜索方法不切实际。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-167">If it takes three months to perform an exhaustive search to retrieve data that is meaningful only for a few days, the exhaustive search method is impractical.</span></span>

<span data-ttu-id="dbb4c-168">密钥加密的缺点是它假定双方已商定密钥和 IV，并互相传达了密钥和 IV 的值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-168">The disadvantage of secret-key encryption is that it presumes two parties have agreed on a key and IV, and communicated their values.</span></span> <span data-ttu-id="dbb4c-169">IV 不被视为机密，并可以以纯文本的形式通过消息传输。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-169">The IV is not considered a secret and can be transmitted in plaintext with the message.</span></span> <span data-ttu-id="dbb4c-170">但是，密钥必须对未经授权的用户保密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-170">However, the key must be kept secret from unauthorized users.</span></span> <span data-ttu-id="dbb4c-171">由于存在这些问题，密钥加密通常与公钥加密一起使用，以秘密地传达密钥和 IV 的值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-171">Because of these problems, secret-key encryption is often used together with public-key encryption to privately communicate the values of the key and IV.</span></span>

<span data-ttu-id="dbb4c-172">假定 Alice 和 Bob 是想通过非安全通道进行通信的双方，则他们可能按如下所示使用密钥加密：Alice 和 Bob 同意使用某种具有特定密钥和 IV 的特定算法（例如 AES）。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-172">Assuming that Alice and Bob are two parties who want to communicate over a nonsecure channel, they might use secret-key encryption as follows: Alice and Bob agree to use one particular algorithm (AES, for example) with a particular key and IV.</span></span> <span data-ttu-id="dbb4c-173">Alice 撰写了一条消息，并创建了一个网络流， (可能要在其上发送消息的命名管道或网络电子邮件) 。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-173">Alice composes a message and creates a network stream (perhaps a named pipe or network email) on which to send the message.</span></span> <span data-ttu-id="dbb4c-174">接下来，她使用密钥和 IV 对文本进行加密，然后通过 intranet 向 Bob 发送加密的消息和 IV。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-174">Next, she encrypts the text using the key and IV, and sends the encrypted message and IV to Bob over the intranet.</span></span> <span data-ttu-id="dbb4c-175">Bob 收到加密文本并使用 IV 和之前商定的密钥对其进行解密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-175">Bob receives the encrypted text and decrypts it by using the IV and previously agreed upon key.</span></span> <span data-ttu-id="dbb4c-176">如果传输被截获，侦听器无法恢复原始消息，因为它们不知道密钥。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-176">If the transmission is intercepted, the interceptor cannot recover the original message, because they do not know the key.</span></span> <span data-ttu-id="dbb4c-177">在此方案中，只有密钥必须保持机密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-177">In this scenario, only the key must remain secret.</span></span> <span data-ttu-id="dbb4c-178">在实际方案中，Alice 和 Bob 都可以生成密钥并使用公钥（非对称）加密将密钥（对称）传递给另一方。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-178">In a real world scenario, either Alice or Bob generates a secret key and uses public-key (asymmetric) encryption to transfer the secret (symmetric) key to the other party.</span></span> <span data-ttu-id="dbb4c-179">有关公钥加密的详细信息，请参阅下一节。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-179">For more information about public-key encryption, see the next section.</span></span>

<span data-ttu-id="dbb4c-180">.NET 提供以下实现密钥加密算法的类：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-180">.NET provides the following classes that implement secret-key encryption algorithms:</span></span>

- <xref:System.Security.Cryptography.Aes>

- <span data-ttu-id="dbb4c-181"><xref:System.Security.Cryptography.HMACSHA256>、<xref:System.Security.Cryptography.HMACSHA384> 和 <xref:System.Security.Cryptography.HMACSHA512>。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-181"><xref:System.Security.Cryptography.HMACSHA256>, <xref:System.Security.Cryptography.HMACSHA384> and <xref:System.Security.Cryptography.HMACSHA512>.</span></span> <span data-ttu-id="dbb4c-182"> (这些是技术上的机密密钥算法，因为它们表示消息身份验证代码，这些代码是通过将加密哈希函数与密钥结合使用来计算的。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-182">(These are technically secret-key algorithms because they represent message authentication codes that are calculated by using a cryptographic hash function combined with a secret key.</span></span> <span data-ttu-id="dbb4c-183">请参阅本文后面部分的 [哈希值](#hash-values)) </span><span class="sxs-lookup"><span data-stu-id="dbb4c-183">See [Hash Values](#hash-values), later in this article.)</span></span>

## <a name="public-key-encryption"></a><span data-ttu-id="dbb4c-184">公钥加密</span><span class="sxs-lookup"><span data-stu-id="dbb4c-184">Public-Key Encryption</span></span>

<span data-ttu-id="dbb4c-185">公钥加密使用必须对从未经授权的用户保密的私钥和可以公开给任何人的公钥。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-185">Public-key encryption uses a private key that must be kept secret from unauthorized users and a public key that can be made public to anyone.</span></span> <span data-ttu-id="dbb4c-186">从数学上来讲，公钥和私钥是相互链接的；使用公钥加密的数据只能用私钥解密，而使用私钥签名的数据只能使用公钥进行验证。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-186">The public key and the private key are mathematically linked; data that is encrypted with the public key can be decrypted only with the private key, and data that is signed with the private key can be verified only with the public key.</span></span> <span data-ttu-id="dbb4c-187">公钥可供任何人使用；它用加密要发到送私钥所有者的数据。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-187">The public key can be made available to anyone; it is used for encrypting data to be sent to the keeper of the private key.</span></span> <span data-ttu-id="dbb4c-188">公钥加密算法也称为非对称算法，因为加密数据需要一个密钥，而解密数据需要另一个密钥。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-188">Public-key cryptographic algorithms are also known as asymmetric algorithms because one key is required to encrypt data, and another key is required to decrypt data.</span></span> <span data-ttu-id="dbb4c-189">基本加密规则禁止密钥重复使用，并且每个通信会话的两个密钥应该是独有的。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-189">A basic cryptographic rule prohibits key reuse, and both keys should be unique for each communication session.</span></span> <span data-ttu-id="dbb4c-190">但是，在实践中，非对称密钥的生存期通常很长。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-190">However, in practice, asymmetric keys are generally long-lived.</span></span>

<span data-ttu-id="dbb4c-191">双方（Alice 和 Bob）可能按如下所示使用公钥加密：首先，Alice 生成公钥/私钥对。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-191">Two parties (Alice and Bob) might use public-key encryption as follows: First, Alice generates a public/private key pair.</span></span> <span data-ttu-id="dbb4c-192">如果 Bob 想要向 Alice 发送一条已加密的消息，他会向她索要公钥。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-192">If Bob wants to send Alice an encrypted message, he asks her for her public key.</span></span> <span data-ttu-id="dbb4c-193">Alice 通过非安全网络向 Bob 发送她的公钥，然后 Bob 使用此密钥对消息进行加密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-193">Alice sends Bob her public key over a nonsecure network, and Bob uses this key to encrypt a message.</span></span> <span data-ttu-id="dbb4c-194">Bob 将加密的消息发送给 Alice，然后她将使用自己的私钥对其进行解密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-194">Bob sends the encrypted message to Alice, and she decrypts it by using her private key.</span></span> <span data-ttu-id="dbb4c-195">如果 Bob 通过非安全通道收到 Alice 的密钥（例如，公用网络），则 Bob 容易受到中间人攻击。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-195">If Bob received Alice's key over a nonsecure channel, such as a public network, Bob is open to a man-in-the-middle attack.</span></span> <span data-ttu-id="dbb4c-196">因此，Bob 必须与 Alice 确认他具有其公钥的正确副本。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-196">Therefore, Bob must verify with Alice that he has a correct copy of her public key.</span></span>

<span data-ttu-id="dbb4c-197">在 Alice 公钥的传输期间，未经授权的代理可能会截获此密钥。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-197">During the transmission of Alice's public key, an unauthorized agent might intercept the key.</span></span> <span data-ttu-id="dbb4c-198">此外，同一代理可能会截获来自 Bob 的加密消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-198">Furthermore, the same agent might intercept the encrypted message from Bob.</span></span> <span data-ttu-id="dbb4c-199">不过，此代理不能使用公钥解密此消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-199">However, the agent cannot decrypt the message with the public key.</span></span> <span data-ttu-id="dbb4c-200">该消息只能用 Alice 的私钥进行解密，而该私钥没有进行传输。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-200">The message can be decrypted only with Alice's private key, which has not been transmitted.</span></span> <span data-ttu-id="dbb4c-201">Alice 不使用她的私钥加密给 Bob 的回复消息，因为任何具有公钥的人都可以解密此消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-201">Alice does not use her private key to encrypt a reply message to Bob, because anyone with the public key could decrypt the message.</span></span> <span data-ttu-id="dbb4c-202">如果 Alice 想要将消息回复给 Bob，她会向 Bob 索要他的公钥，并使用此公钥加密消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-202">If Alice wants to send a message back to Bob, she asks Bob for his public key and encrypts her message using that public key.</span></span> <span data-ttu-id="dbb4c-203">然后，Bob 将使用自己的关联私钥解密消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-203">Bob then decrypts the message using his associated private key.</span></span>

<span data-ttu-id="dbb4c-204">在此方案中，Alice 和 Bob 使用公钥（非对称）加密来传输密钥（对称）并使用密钥加密对双方会话的其余部分进行加密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-204">In this scenario, Alice and Bob use public-key (asymmetric) encryption to transfer a secret (symmetric) key and use secret-key encryption for the remainder of their session.</span></span>

<span data-ttu-id="dbb4c-205">下表提供了公钥和密钥加密算法之间的比较：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-205">The following list offers comparisons between public-key and secret-key cryptographic algorithms:</span></span>

- <span data-ttu-id="dbb4c-206">公钥加密算法使用固定的缓冲区大小，而密钥加密算法使用长度可变的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-206">Public-key cryptographic algorithms use a fixed buffer size, whereas secret-key cryptographic algorithms use a variable-length buffer.</span></span>

- <span data-ttu-id="dbb4c-207">公钥算法不能用于以密钥算法可用的方式将数据一起链接到流中，因为只可以加密少量数据。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-207">Public-key algorithms cannot be used to chain data together into streams the way secret-key algorithms can, because only small amounts of data can be encrypted.</span></span> <span data-ttu-id="dbb4c-208">因此，不对称操作不使用与对称操作相同的流式处理模型。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-208">Therefore, asymmetric operations do not use the same streaming model as symmetric operations.</span></span>

- <span data-ttu-id="dbb4c-209">相对于密钥加密，公钥加密具有大得多的密钥空间（密钥的可能值的范围）。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-209">Public-key encryption has a much larger keyspace (range of possible values for the key) than secret-key encryption.</span></span> <span data-ttu-id="dbb4c-210">因此，公钥加密更不易遭受尝试每个可能的密钥的穷举攻击。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-210">Therefore, public-key encryption is less susceptible to exhaustive attacks that try every possible key.</span></span>

- <span data-ttu-id="dbb4c-211">公钥易于分发，因为它们不必要进行保护，前提是存在一些用来验证发件人身份的方式。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-211">Public keys are easy to distribute because they do not have to be secured, provided that some way exists to verify the identity of the sender.</span></span>

- <span data-ttu-id="dbb4c-212">一些公钥算法（例如 RSA 和 DSA，但不是 Diffie-Hellman）可用于创建数字签名以验证数据发件人的身份。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-212">Some public-key algorithms (such as RSA and DSA, but not Diffie-Hellman) can be used to create digital signatures to verify the identity of the sender of data.</span></span>

- <span data-ttu-id="dbb4c-213">公钥算法与密钥算法相比非常慢，且其设计目的不是用于加密大量数据。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-213">Public-key algorithms are very slow compared with secret-key algorithms, and are not designed to encrypt large amounts of data.</span></span> <span data-ttu-id="dbb4c-214">公钥算法仅对传输极少量的数据很有用。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-214">Public-key algorithms are useful only for transferring very small amounts of data.</span></span> <span data-ttu-id="dbb4c-215">通常情况下，公钥加密用于加密密钥算法要使用的密钥和 IV。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-215">Typically, public-key encryption is used to encrypt a key and IV to be used by a secret-key algorithm.</span></span> <span data-ttu-id="dbb4c-216">在密钥和 IV 传输完成后，密钥加密将用于对会话的其余部分加密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-216">After the key and IV are transferred, secret-key encryption is used for the remainder of the session.</span></span>

<span data-ttu-id="dbb4c-217">.NET 提供了以下实现公钥算法的类：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-217">.NET provides the following classes that implement public-key algorithms:</span></span>

- <xref:System.Security.Cryptography.RSA>

- <xref:System.Security.Cryptography.ECDsa>

- <xref:System.Security.Cryptography.ECDiffieHellman>

- <xref:System.Security.Cryptography.DSA>

<span data-ttu-id="dbb4c-218">RSA 允许加密和签名，但 DSA 仅可用于签名。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-218">RSA allows both encryption and signing, but DSA can be used only for signing.</span></span> <span data-ttu-id="dbb4c-219">DSA 不如 RSA 那么安全，我们建议 RSA。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-219">DSA is not as secure as RSA, and we recommend RSA.</span></span> <span data-ttu-id="dbb4c-220">Diffie-hellman 仅可用于生成密钥。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-220">Diffie-Hellman can be used only for key generation.</span></span> <span data-ttu-id="dbb4c-221">一般情况下，公钥算法的使用比私钥算法的更受限制。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-221">In general, public-key algorithms are more limited in their uses than private-key algorithms.</span></span>

## <a name="digital-signatures"></a><span data-ttu-id="dbb4c-222">数字签名</span><span class="sxs-lookup"><span data-stu-id="dbb4c-222">Digital Signatures</span></span>

<span data-ttu-id="dbb4c-223">公钥算法还可用于构成数字签名。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-223">Public-key algorithms can also be used to form digital signatures.</span></span> <span data-ttu-id="dbb4c-224">数字签名会验证发件人的身份（如果信任发件人的公钥），并有助于保护数据的完整性。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-224">Digital signatures authenticate the identity of a sender (if you trust the sender's public key) and help protect the integrity of data.</span></span> <span data-ttu-id="dbb4c-225">使用 Alice 生成的公钥，Alice 的数据的收件人可通过将数字签名与 Alice 的数据及其公钥进行比较来验证数据是否由 Alice 发送。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-225">Using a public key generated by Alice, the recipient of Alice's data can verify that Alice sent it by comparing the digital signature to Alice's data and Alice's public key.</span></span>

<span data-ttu-id="dbb4c-226">若要使用公钥加密以数字方式签署一条消息，Alice 首先要将哈希算法应用于此消息，以创建消息摘要。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-226">To use public-key cryptography to digitally sign a message, Alice first applies a hash algorithm to the message to create a message digest.</span></span> <span data-ttu-id="dbb4c-227">消息摘要是数据紧凑且唯一的表示形式。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-227">The message digest is a compact and unique representation of data.</span></span> <span data-ttu-id="dbb4c-228">然后，Alice 使用她的私钥加密此消息摘要，以创建她的个人签名。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-228">Alice then encrypts the message digest with her private key to create her personal signature.</span></span> <span data-ttu-id="dbb4c-229">在收到消息和签名后，Bob 将使用 Alice 的公钥解密签名，以恢复此消息摘要，并且将使用 Alice 所使用的同一个哈希算法对消息进行哈希运算。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-229">Upon receiving the message and signature, Bob decrypts the signature using Alice's public key to recover the message digest and hashes the message using the same hash algorithm that Alice used.</span></span> <span data-ttu-id="dbb4c-230">如果 Bob 计算的消息摘要与从 Alice 处收到的消息摘要完全匹配，Bob 就可以确定此消息来自私钥的持有人且数据不曾被修改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-230">If the message digest that Bob computes exactly matches the message digest received from Alice, Bob is assured that the message came from the possessor of the private key and that the data has not been modified.</span></span> <span data-ttu-id="dbb4c-231">如果 Bob 信任 Alice 就是私钥的持有人，他就会知道此消息来自 Alice。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-231">If Bob trusts that Alice is the possessor of the private key, he knows that the message came from Alice.</span></span>

> [!NOTE]
> <span data-ttu-id="dbb4c-232">任何人都可以验证签名，因为发件人的公钥众所周知，并且通常包含在数字签名格式中。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-232">A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format.</span></span> <span data-ttu-id="dbb4c-233">此方法不会保留消息的秘密性；对于机密消息，它也必须加密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-233">This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.</span></span>

<span data-ttu-id="dbb4c-234">.NET 提供以下实现数字签名算法的类：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-234">.NET provides the following classes that implement digital signature algorithms:</span></span>

- <xref:System.Security.Cryptography.RSA>

- <xref:System.Security.Cryptography.ECDsa>

- <xref:System.Security.Cryptography.DSA>

## <a name="hash-values"></a><span data-ttu-id="dbb4c-235">哈希值</span><span class="sxs-lookup"><span data-stu-id="dbb4c-235">Hash Values</span></span>

<span data-ttu-id="dbb4c-236">哈希算法将任意长度的二进制值映射到较小的固定长度的二进制值，称为哈希值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-236">Hash algorithms map binary values of an arbitrary length to smaller binary values of a fixed length, known as hash values.</span></span> <span data-ttu-id="dbb4c-237">哈希值是一段数据的数值表示形式。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-237">A hash value is a numerical representation of a piece of data.</span></span> <span data-ttu-id="dbb4c-238">如果对一段纯文本进行哈希处理，甚至只更改段落的一个字母，随后的哈希运算都将产生不同的值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-238">If you hash a paragraph of plaintext and change even one letter of the paragraph, a subsequent hash will produce a different value.</span></span> <span data-ttu-id="dbb4c-239">如果哈希是加密型强哈希，则其值将有明显的更改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-239">If the hash is cryptographically strong, its value will change significantly.</span></span> <span data-ttu-id="dbb4c-240">例如，如果更改了消息中的一个位，强哈希函数可能会生成相差 50% 的输出。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-240">For example, if a single bit of a message is changed, a strong hash function may produce an output that differs by 50 percent.</span></span> <span data-ttu-id="dbb4c-241">许多输入值可能哈希处理为相同的输出值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-241">Many input values may hash to the same output value.</span></span> <span data-ttu-id="dbb4c-242">但是，它无法以计算方式找到哈希处理为同一值的两个不同的输入。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-242">However, it is computationally infeasible to find two distinct inputs that hash to the same value.</span></span>

<span data-ttu-id="dbb4c-243">双方（Alice 和 Bob）可以使用哈希函数来确保消息的完整性。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-243">Two parties (Alice and Bob) could use a hash function to ensure message integrity.</span></span> <span data-ttu-id="dbb4c-244">他们会选择要对其消息进行签名的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-244">They would select a hash algorithm to sign their messages.</span></span> <span data-ttu-id="dbb4c-245">Alice 将编写一条消息，然后使用所选的算法为此消息创建一个哈希值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-245">Alice would write a message, and then create a hash of that message by using the selected algorithm.</span></span> <span data-ttu-id="dbb4c-246">然后，他们将按以下方法之一执行操作：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-246">They would then follow one of the following methods:</span></span>

- <span data-ttu-id="dbb4c-247">Alice 向 Bob 发送纯文本消息和经过哈希处理的消息（数字签名）。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-247">Alice sends the plaintext message and the hashed message (digital signature) to Bob.</span></span> <span data-ttu-id="dbb4c-248">Bob 接收消息并进行哈希处理，然后将其哈希值与从 Alice 处接收到的哈希值进行比较。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-248">Bob receives and hashes the message and compares his hash value to the hash value that he received from Alice.</span></span> <span data-ttu-id="dbb4c-249">如果哈希值相同，则消息未更改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-249">If the hash values are identical, the message was not altered.</span></span> <span data-ttu-id="dbb4c-250">如果值不同，则消息在 Alice 编写后遭到更改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-250">If the values are not identical, the message was altered after Alice wrote it.</span></span>

  <span data-ttu-id="dbb4c-251">遗憾的是，此方法不会确定发件人的真伪。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-251">Unfortunately, this method does not establish the authenticity of the sender.</span></span> <span data-ttu-id="dbb4c-252">任何人都可以模仿 Alice 并向 Bob 发送消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-252">Anyone can impersonate Alice and send a message to Bob.</span></span> <span data-ttu-id="dbb4c-253">他们可以使用相同的哈希算法来签署消息，而 Bob 可确定的只是消息与它的签名相匹配。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-253">They can use the same hash algorithm to sign their message, and all Bob can determine is that the message matches its signature.</span></span> <span data-ttu-id="dbb4c-254">这是中间人攻击的一种形式。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-254">This is one form of a man-in-the-middle attack.</span></span> <span data-ttu-id="dbb4c-255">有关详细信息，请参阅 [下一代加密 (CNG) 安全通信示例](/previous-versions/cc488018(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-255">For more information, see [Cryptography Next Generation (CNG) Secure Communication Example](/previous-versions/cc488018(v=vs.100)).</span></span>

- <span data-ttu-id="dbb4c-256">Alice 通过非安全的公共通道向 Bob 发送纯文本消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-256">Alice sends the plaintext message to Bob over a nonsecure public channel.</span></span> <span data-ttu-id="dbb4c-257">Alice 通过安全的专用通道向 Bob 发送经过哈希处理的消息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-257">She sends the hashed message to Bob over a secure private channel.</span></span> <span data-ttu-id="dbb4c-258">Bob 接收纯文本消息，对其进行哈希处理并将此哈希值与私下交换的哈希值进行比较。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-258">Bob receives the plaintext message, hashes it, and compares the hash to the privately exchanged hash.</span></span> <span data-ttu-id="dbb4c-259">如果哈希值匹配，则 Bob 知道两件事：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-259">If the hashes match, Bob knows two things:</span></span>

  - <span data-ttu-id="dbb4c-260">消息未被更改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-260">The message was not altered.</span></span>

  - <span data-ttu-id="dbb4c-261">消息的发件人 (Alice) 是可信的。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-261">The sender of the message (Alice) is authentic.</span></span>

  <span data-ttu-id="dbb4c-262">为使此系统发挥作用，Alice 必须对 Bob 之外的所有方隐藏她的原始哈希值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-262">For this system to work, Alice must hide her original hash value from all parties except Bob.</span></span>

- <span data-ttu-id="dbb4c-263">Alice 通过非安全的公共通道向 Bob 发送纯文本消息，并将经过哈希处理的消息放置在其公开可见的网站上。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-263">Alice sends the plaintext message to Bob over a nonsecure public channel and places the hashed message on her publicly viewable Web site.</span></span>

  <span data-ttu-id="dbb4c-264">此方法可以通过防止任何人修改哈希值，从而防止消息遭到篡改。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-264">This method prevents message tampering by preventing anyone from modifying the hash value.</span></span> <span data-ttu-id="dbb4c-265">尽管任何人都可读取此消息及其哈希值，但只有 Alice 可以更改哈希值。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-265">Although the message and its hash can be read by anyone, the hash value can be changed only by Alice.</span></span> <span data-ttu-id="dbb4c-266">想要模仿 Alice 的攻击者将需要访问 Alice 的网站。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-266">An attacker who wants to impersonate Alice would require access to Alice's Web site.</span></span>

<span data-ttu-id="dbb4c-267">之前的方法都无法防止他人读取 Alice 的消息，因为消息是以纯文本的形式传输的。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-267">None of the previous methods will prevent someone from reading Alice's messages, because they are transmitted in plaintext.</span></span> <span data-ttu-id="dbb4c-268">完整安全模式通常要求数字签名（消息签名）和加密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-268">Full security typically requires digital signatures (message signing) and encryption.</span></span>

<span data-ttu-id="dbb4c-269">.NET 提供了以下实现哈希算法的类：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-269">.NET provides the following classes that implement hashing algorithms:</span></span>

- <span data-ttu-id="dbb4c-270"><xref:System.Security.Cryptography.SHA256>.</span><span class="sxs-lookup"><span data-stu-id="dbb4c-270"><xref:System.Security.Cryptography.SHA256>.</span></span>

- <span data-ttu-id="dbb4c-271"><xref:System.Security.Cryptography.SHA384>.</span><span class="sxs-lookup"><span data-stu-id="dbb4c-271"><xref:System.Security.Cryptography.SHA384>.</span></span>

- <span data-ttu-id="dbb4c-272"><xref:System.Security.Cryptography.SHA512>.</span><span class="sxs-lookup"><span data-stu-id="dbb4c-272"><xref:System.Security.Cryptography.SHA512>.</span></span>

<span data-ttu-id="dbb4c-273">.NET 还提供了 <xref:System.Security.Cryptography.MD5> 和 <xref:System.Security.Cryptography.SHA1> 。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-273">.NET also provides <xref:System.Security.Cryptography.MD5> and <xref:System.Security.Cryptography.SHA1>.</span></span> <span data-ttu-id="dbb4c-274">但是，MD5 和 SHA-1 算法已发现不安全，现在建议改用 SHA-1。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-274">But the MD5 and SHA-1 algorithms have been found to be insecure, and SHA-2 is now recommended instead.</span></span> <span data-ttu-id="dbb4c-275">SHA-1 包含 SHA256、SHA384 和 SHA512。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-275">SHA-2 includes SHA256, SHA384, and SHA512.</span></span>

## <a name="random-number-generation"></a><span data-ttu-id="dbb4c-276">随机数生成</span><span class="sxs-lookup"><span data-stu-id="dbb4c-276">Random Number Generation</span></span>

<span data-ttu-id="dbb4c-277">随机数生成是很多加密操作的必要组成部分。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-277">Random number generation is integral to many cryptographic operations.</span></span> <span data-ttu-id="dbb4c-278">例如，加密密钥需要尽可能的随机，以便使其很难再现。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-278">For example, cryptographic keys need to be as random as possible so that it is infeasible to reproduce them.</span></span> <span data-ttu-id="dbb4c-279">加密随机数生成器必须生成在计算上预测的可能性不可大于 50% 的输出。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-279">Cryptographic random number generators must generate output that is computationally infeasible to predict with a probability that is better than one half.</span></span> <span data-ttu-id="dbb4c-280">因此，预测下一个输出位的任何方法均不能比随机推测执行地更好。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-280">Therefore, any method of predicting the next output bit must not perform better than random guessing.</span></span> <span data-ttu-id="dbb4c-281">.NET Framework 中的类使用随机数生成器来生成加密密钥。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-281">The classes in the .NET Framework use random number generators to generate cryptographic keys.</span></span>

<span data-ttu-id="dbb4c-282"><xref:System.Security.Cryptography.RandomNumberGenerator> 类是随机数生成器算法的一个实现。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-282">The <xref:System.Security.Cryptography.RandomNumberGenerator> class is an implementation of a random number generator algorithm.</span></span>

## <a name="clickonce-manifests"></a><span data-ttu-id="dbb4c-283">ClickOnce 清单</span><span class="sxs-lookup"><span data-stu-id="dbb4c-283">ClickOnce Manifests</span></span>

<span data-ttu-id="dbb4c-284">在 .NET Framework 3.5 中，以下加密类使你可以获取并验证有关使用 [ClickOnce 技术](/visualstudio/deployment/clickonce-security-and-deployment)部署的应用程序的清单签名的信息：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-284">In the .NET Framework 3.5, the following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using [ClickOnce technology](/visualstudio/deployment/clickonce-security-and-deployment):</span></span>

- <span data-ttu-id="dbb4c-285">当使用清单签名的 <xref:System.Security.Cryptography.ManifestSignatureInformation> 方法重载时， <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> 类将获取此清单签名的相关信息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-285">The <xref:System.Security.Cryptography.ManifestSignatureInformation> class obtains information about a manifest signature when you use its <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> method overloads.</span></span>

- <span data-ttu-id="dbb4c-286">可以使用 <xref:System.Security.ManifestKinds> 枚举来指定要验证的清单。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-286">You can use the <xref:System.Security.ManifestKinds> enumeration to specify which manifests to verify.</span></span> <span data-ttu-id="dbb4c-287">验证的结果是 <xref:System.Security.Cryptography.SignatureVerificationResult> 枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-287">The result of the verification is one of the <xref:System.Security.Cryptography.SignatureVerificationResult> enumeration values.</span></span>

- <span data-ttu-id="dbb4c-288"><xref:System.Security.Cryptography.ManifestSignatureInformationCollection> 类提供已验证签名的 <xref:System.Security.Cryptography.ManifestSignatureInformation> 对象的只读集合。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-288">The <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> class provides a read-only collection of <xref:System.Security.Cryptography.ManifestSignatureInformation> objects of the verified signatures.</span></span>

 <span data-ttu-id="dbb4c-289">此外，以下类提供特定的签名信息：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-289">In addition, the following classes provide specific signature information:</span></span>

- <span data-ttu-id="dbb4c-290"><xref:System.Security.Cryptography.StrongNameSignatureInformation> 包含清单的强名称签名信息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-290"><xref:System.Security.Cryptography.StrongNameSignatureInformation> holds the strong name signature information for a manifest.</span></span>

- <span data-ttu-id="dbb4c-291"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> 表示清单的验证码签名信息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-291"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> represents the Authenticode signature information for a manifest.</span></span>

- <span data-ttu-id="dbb4c-292"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> 包含验证码签名上时间戳的相关信息。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-292"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> contains information about the time stamp on an Authenticode signature.</span></span>

- <span data-ttu-id="dbb4c-293"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> 提供了一个检查验证码签名是否可信的简单方法。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-293"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> provides a simple way to check whether an Authenticode signature is trusted.</span></span>

## <a name="cryptography-next-generation-cng-classes"></a><span data-ttu-id="dbb4c-294">下一代加密技术 (CNG) 类</span><span class="sxs-lookup"><span data-stu-id="dbb4c-294">Cryptography Next Generation (CNG) Classes</span></span>

<span data-ttu-id="dbb4c-295">在 .NET Framework 3.5 及更高版本中，下一代加密技术 (CNG) 类提供了围绕本机 CNG 函数的托管包装。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-295">In the .NET Framework 3.5 and later versions, the Cryptography Next Generation (CNG) classes provide a managed wrapper around the native CNG functions.</span></span> <span data-ttu-id="dbb4c-296"> (CNG 是 CryptoAPI 的替代。 ) 这些类的名称包含 "Cng"。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-296">(CNG is the replacement for CryptoAPI.) These classes have "Cng" as part of their names.</span></span> <span data-ttu-id="dbb4c-297">“中心到 CNG”包装类是 <xref:System.Security.Cryptography.CngKey> 密钥容器类，它将提取 CNG 密钥的存储和用法。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-297">Central to the CNG wrapper classes is the <xref:System.Security.Cryptography.CngKey> key container class, which abstracts the storage and use of CNG keys.</span></span> <span data-ttu-id="dbb4c-298">此类允许安全地存储密钥对或公钥并使用简单的字符串名称对其进行引用。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-298">This class lets you store a key pair or a public key securely and refer to it by using a simple string name.</span></span> <span data-ttu-id="dbb4c-299">基于椭圆曲线的 <xref:System.Security.Cryptography.ECDsaCng> 签名类和 <xref:System.Security.Cryptography.ECDiffieHellmanCng> 加密类可以使用 <xref:System.Security.Cryptography.CngKey> 对象。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-299">The elliptic curve-based <xref:System.Security.Cryptography.ECDsaCng> signature class and the <xref:System.Security.Cryptography.ECDiffieHellmanCng> encryption class can use <xref:System.Security.Cryptography.CngKey> objects.</span></span>

<span data-ttu-id="dbb4c-300"><xref:System.Security.Cryptography.CngKey> 类用于各种其他操作，包括打开、创建、删除和导出密钥。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-300">The <xref:System.Security.Cryptography.CngKey> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys.</span></span> <span data-ttu-id="dbb4c-301">在直接调用本机函数时，它还提供对要使用的基础密钥句柄的访问。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-301">It also provides access to the underlying key handle to use when calling native functions directly.</span></span>

<span data-ttu-id="dbb4c-302">.NET Framework 3.5 还包括各种支持的 CNG 类，如下所示：</span><span class="sxs-lookup"><span data-stu-id="dbb4c-302">The .NET Framework 3.5 also includes a variety of supporting CNG classes, such as the following:</span></span>

- <span data-ttu-id="dbb4c-303"><xref:System.Security.Cryptography.CngProvider> 维护密钥存储提供程序。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-303"><xref:System.Security.Cryptography.CngProvider> maintains a key storage provider.</span></span>

- <span data-ttu-id="dbb4c-304"><xref:System.Security.Cryptography.CngAlgorithm> 维护 CNG 算法。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-304"><xref:System.Security.Cryptography.CngAlgorithm> maintains a CNG algorithm.</span></span>

- <span data-ttu-id="dbb4c-305"><xref:System.Security.Cryptography.CngProperty> 维护经常使用的密钥属性。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-305"><xref:System.Security.Cryptography.CngProperty> maintains frequently used key properties.</span></span>

## <a name="see-also"></a><span data-ttu-id="dbb4c-306">请参阅</span><span class="sxs-lookup"><span data-stu-id="dbb4c-306">See also</span></span>

- <span data-ttu-id="dbb4c-307">[加密模型](cryptography-model.md) -介绍如何在基类库中实现加密。</span><span class="sxs-lookup"><span data-stu-id="dbb4c-307">[Cryptography Model](cryptography-model.md) - Describes how cryptography is implemented in the base class library.</span></span>
- [<span data-ttu-id="dbb4c-308">跨平台加密</span><span class="sxs-lookup"><span data-stu-id="dbb4c-308">Cross-Platform Cryptography</span></span>](cross-platform-cryptography.md)
- [<span data-ttu-id="dbb4c-309">使用填充对 CBC 模式对称解密的漏洞进行计时</span><span class="sxs-lookup"><span data-stu-id="dbb4c-309">Timing vulnerabilities with CBC-mode symmetric decryption using padding</span></span>](vulnerabilities-cbc-mode.md)
- [<span data-ttu-id="dbb4c-310">ASP.NET Core 数据保护</span><span class="sxs-lookup"><span data-stu-id="dbb4c-310">ASP.NET Core Data Protection</span></span>](/aspnet/core/security/data-protection/introduction)
