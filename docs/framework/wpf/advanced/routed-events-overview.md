---
title: 路由事件概述
description: 了解 Windows Presentation Foundation 中的路由事件，包括如何通过元素树路由事件以及如何创建自定义路由事件。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached events [WPF]
- grouped button set [WPF]
- routed events [WPF]
- events [WPF], routed
- tunneling [WPF]
- events [WPF], attached
- routing strategies for events [WPF]
- button set [WPF], grouped
- bubbling [WPF]
ms.assetid: 1a2189ae-13b4-45b0-b12c-8de2e49c29d2
ms.openlocfilehash: d18b511a4886c68922cccac14942eb54e5735a71
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/24/2020
ms.locfileid: "87164805"
---
# <a name="routed-events-overview"></a><span data-ttu-id="e1f3d-103">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="e1f3d-103">Routed Events Overview</span></span>

<span data-ttu-id="e1f3d-104">本主题描述 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中路由事件的概念。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-104">This topic describes the concept of routed events in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="e1f3d-105">本主题定义路由事件术语、描述路由事件如何通过元素树来路由、概述如何处理路由事件，并介绍如何创建你自己的自定义路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-105">The topic defines routed events terminology, describes how routed events are routed through a tree of elements, summarizes how you handle routed events, and introduces how to create your own custom routed events.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="e1f3d-106">先决条件</span><span class="sxs-lookup"><span data-stu-id="e1f3d-106">Prerequisites</span></span>

<span data-ttu-id="e1f3d-107">本主题假定您具有公共语言运行时（CLR）和面向对象的编程的基本知识，以及如何将元素之间的关系概念 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 化为树的概念。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-107">This topic assumes that you have basic knowledge of the common language runtime (CLR) and object-oriented programming, as well as the concept of how the relationships between [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] elements can be conceptualized as a tree.</span></span> <span data-ttu-id="e1f3d-108">若要理解本主题中的示例，你还应当了解 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 并知道如何编写非常基本的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序或页。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-108">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write very basic [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications or pages.</span></span> <span data-ttu-id="e1f3d-109">有关详细信息，请参阅[演练：我的第一个 WPF 桌面应用程序](../getting-started/walkthrough-my-first-wpf-desktop-application.md)和[XAML 概述（WPF）](../../../desktop-wpf/fundamentals/xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-109">For more information, see [Walkthrough: My first WPF desktop application](../getting-started/walkthrough-my-first-wpf-desktop-application.md) and [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>

<a name="routing"></a>

## <a name="what-is-a-routed-event"></a><span data-ttu-id="e1f3d-110">什么是路由事件？</span><span class="sxs-lookup"><span data-stu-id="e1f3d-110">What Is a Routed Event?</span></span>

<span data-ttu-id="e1f3d-111">可以从功能或实现的角度来理解路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-111">You can think about routed events either from a functional or implementation perspective.</span></span> <span data-ttu-id="e1f3d-112">此处对这两种定义均进行了说明，因为有的用户认为前者更有用，有的用户认为后者更有用。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-112">Both definitions are presented here, because some people find one or the other definition more useful.</span></span>

<span data-ttu-id="e1f3d-113">功能定义：路由事件是一种可以针对元素树中的多个侦听器（而不是仅针对引发该事件的对象）调用处理程序的事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-113">Functional definition: A routed event is a type of event that can invoke handlers on multiple listeners in an element tree, rather than just on the object that raised the event.</span></span>

<span data-ttu-id="e1f3d-114">实现定义：路由事件是由类的实例支持的 CLR 事件，由 <xref:System.Windows.RoutedEvent> [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 事件系统进行处理。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-114">Implementation definition: A routed event is a CLR event that is backed by an instance of the <xref:System.Windows.RoutedEvent> class and is processed by the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] event system.</span></span>

<span data-ttu-id="e1f3d-115">典型的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 应用程序中包含许多元素。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-115">A typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application contains many elements.</span></span> <span data-ttu-id="e1f3d-116">无论这些元素是在代码中创建还是在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中声明，它们存在于彼此关联的元素树关系中。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-116">Whether created in code or declared in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], these elements exist in an element tree relationship to each other.</span></span> <span data-ttu-id="e1f3d-117">根据事件的定义，事件路由可以按两种方向之一传播，但是通常会在元素树中从源元素向上“浮升”，直到它到达元素树的根（通常是页面或窗口）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-117">The event route can travel in one of two directions depending on the event definition, but generally the route travels from the source element and then "bubbles" upward through the element tree until it reaches the element tree root (typically a page or a window).</span></span> <span data-ttu-id="e1f3d-118">如果你以前用过 DHTML 对象模型，则可能会熟悉这个浮升概念。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-118">This bubbling concept might be familiar to you if you have worked with the DHTML object model previously.</span></span>

<span data-ttu-id="e1f3d-119">请思考下面的简单元素树：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-119">Consider the following simple element tree:</span></span>

[!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]

<span data-ttu-id="e1f3d-120">此元素树生成类似如下的内容：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-120">This element tree produces something like the following:</span></span>

<span data-ttu-id="e1f3d-121">!["是"、"否" 和 "取消" 按钮](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")</span><span class="sxs-lookup"><span data-stu-id="e1f3d-121">![Yes, No, and Cancel buttons](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")</span></span>

<span data-ttu-id="e1f3d-122">在这个简化的元素树中，事件的源 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 是一个 <xref:System.Windows.Controls.Button> 元素，而 <xref:System.Windows.Controls.Button> 单击的是有机会处理事件的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-122">In this simplified element tree, the source of a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event is one of the <xref:System.Windows.Controls.Button> elements, and whichever <xref:System.Windows.Controls.Button> was clicked is the first element that has the opportunity to handle the event.</span></span> <span data-ttu-id="e1f3d-123">但如果附加到的处理程序对 <xref:System.Windows.Controls.Button> 事件不起作用，则该事件将向上冒泡到 <xref:System.Windows.Controls.Button> 元素树中的父级（即） <xref:System.Windows.Controls.StackPanel> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-123">But if no handler attached to the <xref:System.Windows.Controls.Button> acts on the event, then the event will bubble upwards to the <xref:System.Windows.Controls.Button> parent in the element tree, which is the <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="e1f3d-124">事件可能会冒泡到 <xref:System.Windows.Controls.Border> ，然后再冒泡到元素树的页根（未显示）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-124">Potentially, the event bubbles to <xref:System.Windows.Controls.Border>, and then beyond to the page root of the element tree (not shown).</span></span>

<span data-ttu-id="e1f3d-125">换句话说，此事件的事件路由 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 是：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-125">In other words, the event route for this <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event is:</span></span>

<span data-ttu-id="e1f3d-126">Button-->StackPanel-->Border-->...</span><span class="sxs-lookup"><span data-stu-id="e1f3d-126">Button-->StackPanel-->Border-->...</span></span>

### <a name="top-level-scenarios-for-routed-events"></a><span data-ttu-id="e1f3d-127">路由事件的顶级方案</span><span class="sxs-lookup"><span data-stu-id="e1f3d-127">Top-level Scenarios for Routed Events</span></span>

<span data-ttu-id="e1f3d-128">下面简要概述了引发路由事件的方案，以及为什么典型的 CLR 事件对于这些方案来说是不够的：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-128">The following is a brief summary of the scenarios that motivated the routed event concept, and why a typical CLR event was not adequate for these scenarios:</span></span>

<span data-ttu-id="e1f3d-129">**控件的撰写和封装：**[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的各个控件都有一个丰富的内容模型。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-129">**Control composition and encapsulation:** Various controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have a rich content model.</span></span> <span data-ttu-id="e1f3d-130">例如，可以将图像置于内 <xref:System.Windows.Controls.Button> ，这会有效地扩展按钮的可视化树。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-130">For example, you can place an image inside of a <xref:System.Windows.Controls.Button>, which effectively extends the visual tree of the button.</span></span> <span data-ttu-id="e1f3d-131">但是，添加的图像不得中断导致按钮响应 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 其内容的命中测试行为，即使用户单击了在技术上包含图像的部分像素也是如此。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-131">However, the added image must not break the hit-testing behavior that causes a button to respond to a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> of its content, even if the user clicks on pixels that are technically part of the image.</span></span>

<span data-ttu-id="e1f3d-132">**单一处理程序附件点：** 在 Windows 窗体中，你必须多次附加相同的处理程序，以处理可能会从多个元素引发的事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-132">**Singular handler attachment points:** In Windows Forms, you would have to attach the same handler multiple times to process events that could be raised from multiple elements.</span></span> <span data-ttu-id="e1f3d-133">借助路由事件，可以只附加该处理程序一次（如上例中所示），并在必要时使用处理程序逻辑来确定该事件的源位置。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-133">Routed events enable you to attach that handler only once, as was shown in the previous example, and use handler logic to determine where the event came from if necessary.</span></span> <span data-ttu-id="e1f3d-134">例如，这可以是前面显示的 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 的处理程序：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-134">For instance, this might be the handler for the previously shown [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]:</span></span>

[!code-csharp[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#groupbuttoncodebehind)]
[!code-vb[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#groupbuttoncodebehind)]

<span data-ttu-id="e1f3d-135">**类处理：** 路由事件允许使用由类定义的静态处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-135">**Class handling:** Routed events permit a static handler that is defined by the class.</span></span> <span data-ttu-id="e1f3d-136">此类处理程序能够抢在任何附加的实例处理程序之前处理事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-136">This class handler has the opportunity to handle an event before any attached instance handlers can.</span></span>

<span data-ttu-id="e1f3d-137">**引用事件，而不反射：** 某些代码和标记技术需要能标识特定事件的方法。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-137">**Referencing an event without reflection:** Certain code and markup techniques require a way to identify a specific event.</span></span> <span data-ttu-id="e1f3d-138">路由事件将 <xref:System.Windows.RoutedEvent> 字段作为标识符创建，这提供了一种可靠的事件标识技术，不需要静态或运行时反射。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-138">A routed event creates a <xref:System.Windows.RoutedEvent> field as an identifier, which provides a robust event identification technique that does not require static or run-time reflection.</span></span>

### <a name="how-routed-events-are-implemented"></a><span data-ttu-id="e1f3d-139">路由事件的实现方式</span><span class="sxs-lookup"><span data-stu-id="e1f3d-139">How Routed Events Are Implemented</span></span>

<span data-ttu-id="e1f3d-140">路由事件是由类的实例提供支持 <xref:System.Windows.RoutedEvent> 并向事件系统注册的 CLR 事件 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-140">A routed event is a CLR event that is backed by an instance of the <xref:System.Windows.RoutedEvent> class and registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="e1f3d-141"><xref:System.Windows.RoutedEvent>从注册获得的实例通常作为 `public` `static` `readonly` 类的字段成员保留，此类成员注册并因此 "拥有" 路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-141">The <xref:System.Windows.RoutedEvent> instance obtained from registration is typically retained as a `public` `static` `readonly` field member of the class that registers and thus "owns" the routed event.</span></span> <span data-ttu-id="e1f3d-142">与名称相同的 CLR 事件（有时称为 "包装" 事件）的连接是通过重写 `add` CLR 事件的和实现来完成的 `remove` 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-142">The connection to the identically named CLR event (which is sometimes termed the "wrapper" event) is accomplished by overriding the `add` and `remove` implementations for the CLR event.</span></span> <span data-ttu-id="e1f3d-143">通常，`add` 和 `remove` 保留为隐式默认值，该默认值使用特定于语言的相应事件语法来添加和删除该事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-143">Ordinarily, the `add` and `remove` are left as an implicit default that uses the appropriate language-specific event syntax for adding and removing handlers of that event.</span></span> <span data-ttu-id="e1f3d-144">路由事件支持和连接机制在概念上类似于依赖属性是由 <xref:System.Windows.DependencyProperty> 类支持并向属性系统注册的 CLR 属性 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-144">The routed event backing and connection mechanism is conceptually similar to how a dependency property is a CLR property that is backed by the <xref:System.Windows.DependencyProperty> class and registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system.</span></span>

<span data-ttu-id="e1f3d-145">下面的示例演示自定义 `Tap` 路由事件的声明，其中包括标识符字段的注册和公开以及 <xref:System.Windows.RoutedEvent> `add` CLR 事件的和 `remove` 实现 `Tap` 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-145">The following example shows the declaration for a custom `Tap` routed event, including the registration and exposure of the <xref:System.Windows.RoutedEvent> identifier field and the `add` and `remove` implementations for the `Tap` CLR event.</span></span>

[!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
[!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]

### <a name="routed-event-handlers-and-xaml"></a><span data-ttu-id="e1f3d-146">路由事件处理程序和 XAML</span><span class="sxs-lookup"><span data-stu-id="e1f3d-146">Routed Event Handlers and XAML</span></span>

<span data-ttu-id="e1f3d-147">若要使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 为事件添加处理程序，可将该事件的名称声明为用作事件侦听器的元素的属性。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-147">To add a handler for an event using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], you declare the event name as an attribute on the element that is an event listener.</span></span> <span data-ttu-id="e1f3d-148">该属性的值是所实现的处理程序方法的名称，该方法必须存在于代码隐藏文件的分部类中。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-148">The value of the attribute is the name of your implemented handler method, which must exist in the partial class of the code-behind file.</span></span>

[!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]

<span data-ttu-id="e1f3d-149">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]添加路由事件处理程序的语法与添加路由事件处理程序的语法相同，因为您实际上是将处理程序添加到 CLR 事件包装器，后者在下面具有路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-149">The [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax for adding standard CLR event handlers is the same for adding routed event handlers, because you are really adding handlers to the CLR event wrapper, which has a routed event implementation underneath.</span></span> <span data-ttu-id="e1f3d-150">有关在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中添加事件处理程序的详细信息，请参阅 [XAML 概述 (WPF)](../../../desktop-wpf/fundamentals/xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-150">For more information about adding event handlers in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], see [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>

<a name="routing_strategies"></a>

## <a name="routing-strategies"></a><span data-ttu-id="e1f3d-151">路由策略</span><span class="sxs-lookup"><span data-stu-id="e1f3d-151">Routing Strategies</span></span>

<span data-ttu-id="e1f3d-152">路由事件使用以下三种路由策略之一：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-152">Routed events use one of three routing strategies:</span></span>

- <span data-ttu-id="e1f3d-153">**浮升：** 调用事件源上的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-153">**Bubbling:** Event handlers on the event source are invoked.</span></span> <span data-ttu-id="e1f3d-154">路由事件随后会路由到后续的父级元素，直到到达元素树的根。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-154">The routed event then routes to successive parent elements until reaching the element tree root.</span></span> <span data-ttu-id="e1f3d-155">大多数路由事件都使用浮升路由策略。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-155">Most routed events use the bubbling routing strategy.</span></span> <span data-ttu-id="e1f3d-156">浮升路由事件通常用于报告来自不同控件或其他 UI 元素的输入或状态变化。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-156">Bubbling routed events are generally used to report input or state changes from distinct controls or other UI elements.</span></span>

- <span data-ttu-id="e1f3d-157">**直接：** 只有源元素本身才有机会调用处理程序以进行响应。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-157">**Direct:** Only the source element itself is given the opportunity to invoke handlers in response.</span></span> <span data-ttu-id="e1f3d-158">这类似于 Windows 窗体用于事件的 "路由"。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-158">This is analogous to the "routing" that Windows Forms uses for events.</span></span> <span data-ttu-id="e1f3d-159">但是，与标准 CLR 事件不同，直接路由事件支持类处理（在下一节中介绍类处理），并可由 <xref:System.Windows.EventSetter> 和使用 <xref:System.Windows.EventTrigger> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-159">However, unlike a standard CLR event, direct routed events support class handling (class handling is explained in an upcoming section) and can be used by <xref:System.Windows.EventSetter> and <xref:System.Windows.EventTrigger>.</span></span>

- <span data-ttu-id="e1f3d-160">**隧道：** 最初将调用元素树的根处的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-160">**Tunneling:** Initially, event handlers at the element tree root are invoked.</span></span> <span data-ttu-id="e1f3d-161">随后，路由事件将朝着路由事件的源节点元素（即引发路由事件的元素）方向，沿路由线路传播到后续的子元素。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-161">The routed event then travels a route through successive child elements along the route, towards the node element that is the routed event source (the element that raised the routed event).</span></span> <span data-ttu-id="e1f3d-162">合成控件的过程中通常会使用或处理隧道路由事件，通过这种方式，可以有意地禁止复合部件中的事件，或者将其替换为特定于整个控件的事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-162">Tunneling routed events are often used or handled as part of the compositing for a control, such that events from composite parts can be deliberately suppressed or replaced by events that are specific to the complete control.</span></span> <span data-ttu-id="e1f3d-163">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中提供的输入事件通常是以隧道/浮升对实现的。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-163">Input events provided in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] often come implemented as a tunneling/bubbling pair.</span></span> <span data-ttu-id="e1f3d-164">隧道事件有时又称作预览事件，这是由该对所使用的命名约定决定的。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-164">Tunneling events are also sometimes referred to as Preview events, because of a naming convention that is used for the pairs.</span></span>

<a name="why_use"></a>

## <a name="why-use-routed-events"></a><span data-ttu-id="e1f3d-165">为什么使用路由事件？</span><span class="sxs-lookup"><span data-stu-id="e1f3d-165">Why Use Routed Events?</span></span>

<span data-ttu-id="e1f3d-166">作为应用程序开发人员，你不需要始终了解或关注要处理的事件是否作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-166">As an application developer, you do not always need to know or care that the event you are handling is implemented as a routed event.</span></span> <span data-ttu-id="e1f3d-167">路由事件具有特殊的行为，但是，如果在引发该行为的元素上处理事件，则该行为通常会不可见。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-167">Routed events have special behavior, but that behavior is largely invisible if you are handling an event on the element where it is raised.</span></span>

<span data-ttu-id="e1f3d-168">如果使用以下任一建议方案，路由事件的功能将得到充分发挥：在公用根处定义公用处理程序、合成自己的控件或者定义自己的自定义控件类。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-168">Where routed events become powerful is if you use any of the suggested scenarios: defining common handlers at a common root, compositing your own control, or defining your own custom control class.</span></span>

<span data-ttu-id="e1f3d-169">路由事件侦听器和路由事件源不必在其层次结构中共享公用事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-169">Routed event listeners and routed event sources do not need to share a common event in their hierarchy.</span></span> <span data-ttu-id="e1f3d-170">Any <xref:System.Windows.UIElement> 或 <xref:System.Windows.ContentElement> 可以是任何路由事件的事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-170">Any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> can be an event listener for any routed event.</span></span> <span data-ttu-id="e1f3d-171">因此，可以将整个工作 API 集中可用的完整路由事件集用作概念 "接口"，应用程序中的不同元素可以交换事件信息。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-171">Therefore, you can use the full set of routed events available throughout the working API set as a conceptual "interface" whereby disparate elements in the application can exchange event information.</span></span> <span data-ttu-id="e1f3d-172">路由事件的这个“接口”概念特别适用于输入事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-172">This "interface" concept for routed events is particularly applicable for input events.</span></span>

<span data-ttu-id="e1f3d-173">路由事件还可以用于通过元素树进行通信，因为事件的事件数据会保留到路由中的每个元素中。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-173">Routed events can also be used to communicate through the element tree, because the event data for the event is perpetuated to each element in the route.</span></span> <span data-ttu-id="e1f3d-174">一个元素可以更改事件数据中的某些内容，该更改将用于路由中的下一个元素。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-174">One element could change something in the event data, and that change would be available to the next element in the route.</span></span>

<span data-ttu-id="e1f3d-175">除了路由方面以外，还有两个原因，任何给定事件都 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 可能作为路由事件实现，而不是作为标准 CLR 事件实现。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-175">Other than the routing aspect, there are two other reasons that any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event might be implemented as a routed event instead of a standard CLR event.</span></span> <span data-ttu-id="e1f3d-176">如果要实现自己的事件，则可能也需要考虑这些原则：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-176">If you are implementing your own events, you might also consider these principles:</span></span>

- <span data-ttu-id="e1f3d-177">某些 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 样式和模板化功能（如 <xref:System.Windows.EventSetter> 和） <xref:System.Windows.EventTrigger> 要求引用的事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-177">Certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] styling and templating features such as <xref:System.Windows.EventSetter> and <xref:System.Windows.EventTrigger> require the referenced event to be a routed event.</span></span> <span data-ttu-id="e1f3d-178">前面提到的事件标识符方案就是这样的。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-178">This is the event identifier scenario mentioned earlier.</span></span>

- <span data-ttu-id="e1f3d-179">路由事件支持类处理机制，类可以通过该机制来指定静态方法，这些静态方法能够在任何已注册的实例处理程序访问路由事件之前，处理这些路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-179">Routed events support a class handling mechanism whereby the class can specify static methods that have the opportunity to handle routed events before any registered instance handlers can access them.</span></span> <span data-ttu-id="e1f3d-180">这在控件设计中非常有用，因为类可以强制执行事件驱动的类行为，以防它们在处理实例上的事件时被意外禁止。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-180">This is very useful in control design, because your class can enforce event-driven class behaviors that cannot be accidentally suppressed by handling an event on an instance.</span></span>

<span data-ttu-id="e1f3d-181">本主题将用单独的章节来讨论上述每个因素。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-181">Each of the above considerations is discussed in a separate section of this topic.</span></span>

<a name="event_handing"></a>

## <a name="adding-and-implementing-an-event-handler-for-a-routed-event"></a><span data-ttu-id="e1f3d-182">为路由事件添加和实现事件处理程序</span><span class="sxs-lookup"><span data-stu-id="e1f3d-182">Adding and Implementing an Event Handler for a Routed Event</span></span>

<span data-ttu-id="e1f3d-183">若要在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中添加事件处理程序，只需将事件名称作为属性添加到元素中，并将属性值设置为用来实现相应委托的事件处理程序的名称，如下面的示例中所示。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-183">To add an event handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], you simply add the event name to an element as an attribute and set the attribute value as the name of the event handler that implements an appropriate delegate, as in the following example.</span></span>

[!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]

<span data-ttu-id="e1f3d-184">`b1SetColor`是所实现的处理程序的名称，其中包含处理事件的代码 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-184">`b1SetColor` is the name of the implemented handler that contains the code that handles the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="e1f3d-185">`b1SetColor`必须具有与委托相同的签名 <xref:System.Windows.RoutedEventHandler> ，这是事件的事件处理程序委托 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-185">`b1SetColor` must have the same signature as the <xref:System.Windows.RoutedEventHandler> delegate, which is the event handler delegate for the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="e1f3d-186">所有路由事件处理程序委托的第一个参数都指定要向其中添加事件处理程序的元素，第二个参数指定事件的数据。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-186">The first parameter of all routed event handler delegates specifies the element to which the event handler is added, and the second parameter specifies the data for the event.</span></span>

[!code-csharp[EventOvwSupport#SimpleHandlerA](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlera)]
[!code-vb[EventOvwSupport#SimpleHandlerA](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlera)]

<span data-ttu-id="e1f3d-187"><xref:System.Windows.RoutedEventHandler>基本路由事件处理程序委托。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-187"><xref:System.Windows.RoutedEventHandler> is the basic routed event handler delegate.</span></span> <span data-ttu-id="e1f3d-188">对于针对某些控件或方案的专用路由事件，要用于路由事件处理程序的委托还可能会变得更加专用化，以便可以传输专用的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-188">For routed events that are specialized for certain controls or scenarios, the delegates to use for the routed event handlers also might become more specialized, so that they can transmit specialized event data.</span></span> <span data-ttu-id="e1f3d-189">例如，在常见的输入方案中，可以处理 <xref:System.Windows.UIElement.DragEnter> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-189">For instance, in a common input scenario, you might handle a <xref:System.Windows.UIElement.DragEnter> routed event.</span></span> <span data-ttu-id="e1f3d-190">处理程序应实现 <xref:System.Windows.DragEventHandler> 委托。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-190">Your handler should implement the <xref:System.Windows.DragEventHandler> delegate.</span></span> <span data-ttu-id="e1f3d-191">使用最具体的委托，可以 <xref:System.Windows.DragEventArgs> 在处理程序中处理，并读取 <xref:System.Windows.DragEventArgs.Data%2A> 属性，其中包含拖动操作的剪贴板有效负载。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-191">By using the most specific delegate, you can process the <xref:System.Windows.DragEventArgs> in the handler and read the <xref:System.Windows.DragEventArgs.Data%2A> property, which contains the clipboard payload of the drag operation.</span></span>

<span data-ttu-id="e1f3d-192">有关如何使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 向元素中添加事件处理程序的完整示例，请参阅[处理路由事件](how-to-handle-a-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-192">For a complete example of how to add an event handler to an element using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], see [Handle a Routed Event](how-to-handle-a-routed-event.md).</span></span>

<span data-ttu-id="e1f3d-193">在用代码创建的应用程序中为路由事件添加处理程序非常简单。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-193">Adding a handler for a routed event in an application that is created in code is straightforward.</span></span> <span data-ttu-id="e1f3d-194">路由事件处理程序始终可以通过 helper 方法添加 <xref:System.Windows.UIElement.AddHandler%2A> （与现有的支持调用相同的方法 `add` ）。但是，现有 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 路由事件通常具有 `add` 和逻辑的后备实现， `remove` 这些实现允许路由事件的处理程序通过特定于语言的事件语法来添加，该语法比 helper 方法更直观。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-194">Routed event handlers can always be added through a helper method <xref:System.Windows.UIElement.AddHandler%2A> (which is the same method that the existing backing calls for `add`.) However, existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events generally have backing implementations of `add` and `remove` logic that allow the handlers for routed events to be added by a language-specific event syntax, which is more intuitive syntax than the helper method.</span></span> <span data-ttu-id="e1f3d-195">下面是 Helper 方法的示例用法：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-195">The following is an example usage of the helper method:</span></span>

[!code-csharp[EventOvwSupport#AddHandlerCode](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlercode)]
[!code-vb[EventOvwSupport#AddHandlerCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlercode)]

<span data-ttu-id="e1f3d-196">下一个示例演示了 c # 运算符语法（Visual Basic 的运算符语法略有不同，因为它处理取消引用）：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-196">The next example shows the C# operator syntax (Visual Basic has slightly different operator syntax because of its handling of dereferencing):</span></span>

[!code-csharp[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlerplusequals)]
[!code-vb[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlerplusequals)]

<span data-ttu-id="e1f3d-197">有关如何在代码中添加事件处理程序的示例，请参阅[使用代码添加事件处理程序](how-to-add-an-event-handler-using-code.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-197">For an example of how to add an event handler in code, see [Add an Event Handler Using Code](how-to-add-an-event-handler-using-code.md).</span></span>

<span data-ttu-id="e1f3d-198">如果使用 Visual Basic，则还可以使用 `Handles` 关键字将处理程序添加为处理程序声明的一部分。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-198">If you are using Visual Basic, you can also use the `Handles` keyword to add handlers as part of the handler declarations.</span></span> <span data-ttu-id="e1f3d-199">有关详细信息，请参阅 [Visual Basic 和 WPF 事件处理](visual-basic-and-wpf-event-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-199">For more information, see [Visual Basic and WPF Event Handling](visual-basic-and-wpf-event-handling.md).</span></span>

<a name="concept_handled"></a>

### <a name="the-concept-of-handled"></a><span data-ttu-id="e1f3d-200">“已处理”概念</span><span class="sxs-lookup"><span data-stu-id="e1f3d-200">The Concept of Handled</span></span>

<span data-ttu-id="e1f3d-201">所有路由事件都共享一个公用事件数据基类 <xref:System.Windows.RoutedEventArgs> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-201">All routed events share a common event data base class, <xref:System.Windows.RoutedEventArgs>.</span></span> <span data-ttu-id="e1f3d-202"><xref:System.Windows.RoutedEventArgs>定义 <xref:System.Windows.RoutedEventArgs.Handled%2A> 属性，该属性采用布尔值。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-202"><xref:System.Windows.RoutedEventArgs> defines the <xref:System.Windows.RoutedEventArgs.Handled%2A> property, which takes a Boolean value.</span></span> <span data-ttu-id="e1f3d-203">属性的目的 <xref:System.Windows.RoutedEventArgs.Handled%2A> 是使任何事件处理程序沿路由，将路由事件标记为已*处理*，方法是将的值设置 <xref:System.Windows.RoutedEventArgs.Handled%2A> 为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-203">The purpose of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is to enable any event handler along the route to mark the routed event as *handled*, by setting the value of <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span> <span data-ttu-id="e1f3d-204">处理程序在路由上的某个元素处对共享事件数据进行处理之后，这些数据将再次报告给路由上的每个侦听器。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-204">After being processed by the handler at one element along the route, the shared event data is again reported to each listener along the route.</span></span>

<span data-ttu-id="e1f3d-205">的值 <xref:System.Windows.RoutedEventArgs.Handled%2A> 影响路由事件在沿路由进一步传播时的报告或处理方式。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-205">The value of <xref:System.Windows.RoutedEventArgs.Handled%2A> affects how a routed event is reported or processed as it travels further along the route.</span></span> <span data-ttu-id="e1f3d-206">如果 <xref:System.Windows.RoutedEventArgs.Handled%2A> 是 `true` 路由事件的事件数据中的，则通常不会再为该特定事件实例调用在其他元素上侦听该路由事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-206">If <xref:System.Windows.RoutedEventArgs.Handled%2A> is `true` in the event data for a routed event, then handlers that listen for that routed event on other elements are generally no longer invoked for that particular event instance.</span></span> <span data-ttu-id="e1f3d-207">这条规则对以下两类处理程序均适用：在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中附加的处理程序；由特定于语言的事件处理程序附加语法（如 `+=` 或 `Handles`）添加的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-207">This is true both for handlers attached in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and for handlers added by language-specific event handler attachment syntaxes such as `+=` or `Handles`.</span></span> <span data-ttu-id="e1f3d-208">对于大多数常见的处理程序方案，通过将设置为来将事件标记为已处理， <xref:System.Windows.RoutedEventArgs.Handled%2A> `true` 将 "停止" 路由用于隧道路由或冒泡路由，还用于通过类处理程序在路由中的某个点处理的任何事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-208">For most common handler scenarios, marking an event as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` will "stop" routing for either a tunneling route or a bubbling route, and also for any event that is handled at a point in the route by a class handler.</span></span>

<span data-ttu-id="e1f3d-209">但是，有一个 "handledEventsToo" 机制，侦听器仍可以运行处理程序来响应 <xref:System.Windows.RoutedEventArgs.Handled%2A> `true` 事件数据中的路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-209">However, there is a "handledEventsToo" mechanism whereby listeners can still run handlers in response to routed events where <xref:System.Windows.RoutedEventArgs.Handled%2A> is `true` in the event data.</span></span> <span data-ttu-id="e1f3d-210">换言之，将事件数据标记为“已处理”并不会真的停止事件路由。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-210">In other words, the event route is not truly stopped by marking the event data as handled.</span></span> <span data-ttu-id="e1f3d-211">只能在代码中或在中使用 handledEventsToo 机制 <xref:System.Windows.EventSetter> ：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-211">You can only use the handledEventsToo mechanism in code, or in an <xref:System.Windows.EventSetter>:</span></span>

- <span data-ttu-id="e1f3d-212">在代码中，请调用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 方法添加处理程序，而不是使用适用于常规 CLR 事件的特定于语言的事件语法 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-212">In code, instead of using a language-specific event syntax that works for general CLR events, call the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] method <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> to add your handler.</span></span> <span data-ttu-id="e1f3d-213">请将 `handledEventsToo` 的值指定为 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-213">Specify the value of `handledEventsToo` as `true`.</span></span>

- <span data-ttu-id="e1f3d-214">在中 <xref:System.Windows.EventSetter> ，将 <xref:System.Windows.EventSetter.HandledEventsToo%2A> 特性设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-214">In an <xref:System.Windows.EventSetter>, set the <xref:System.Windows.EventSetter.HandledEventsToo%2A> attribute to be `true`.</span></span>

<span data-ttu-id="e1f3d-215">除了 <xref:System.Windows.RoutedEventArgs.Handled%2A> 状态在路由事件中生成的行为外，的概念 <xref:System.Windows.RoutedEventArgs.Handled%2A> 还影响了应如何设计应用程序并编写事件处理程序代码。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-215">In addition to the behavior that <xref:System.Windows.RoutedEventArgs.Handled%2A> state produces in routed events, the concept of <xref:System.Windows.RoutedEventArgs.Handled%2A> has implications for how you should design your application and write the event handler code.</span></span> <span data-ttu-id="e1f3d-216">您可以将概念化为 <xref:System.Windows.RoutedEventArgs.Handled%2A> 由路由事件公开的简单协议。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-216">You can conceptualize <xref:System.Windows.RoutedEventArgs.Handled%2A> as being a simple protocol that is exposed by routed events.</span></span> <span data-ttu-id="e1f3d-217">你确切地了解如何使用此协议，但如何使用的值的概念设计 <xref:System.Windows.RoutedEventArgs.Handled%2A> 如下：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-217">Exactly how you use this protocol is up to you, but the conceptual design for how the value of <xref:System.Windows.RoutedEventArgs.Handled%2A> is intended to be used is as follows:</span></span>

- <span data-ttu-id="e1f3d-218">如果路由事件标记为“已处理”，则它不必由该路由中的其他元素再次处理。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-218">If a routed event is marked as handled, then it does not need to be handled again by other elements along that route.</span></span>

- <span data-ttu-id="e1f3d-219">如果路由事件未标记为已处理，则之前沿路由的其他侦听器选择不注册处理程序，或已注册的处理程序选择不操作事件数据并将设置 <xref:System.Windows.RoutedEventArgs.Handled%2A> 为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-219">If a routed event is not marked as handled, then other listeners that were earlier along the route have chosen either not to register a handler, or the handlers that were registered chose not to manipulate the event data and set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span> <span data-ttu-id="e1f3d-220">（或者，可能当前侦听器是路由中的第一个点。）当前侦听器上的处理程序现在有三个可能的操作课程：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-220">(Or, it is of course possible that the current listener is the first point in the route.) Handlers on the current listener now have three possible courses of action:</span></span>

  - <span data-ttu-id="e1f3d-221">不执行任何操作；该事件保持未处理状态，该事件将路由到下一个侦听器。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-221">Take no action at all; the event remains unhandled, and the event routes to the next listener.</span></span>

  - <span data-ttu-id="e1f3d-222">执行代码以响应该事件，但是所执行的操作被视为不足以保证将事件标记为“已处理”。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-222">Execute code in response to the event, but make the determination that the action taken was not substantial enough to warrant marking the event as handled.</span></span> <span data-ttu-id="e1f3d-223">该事件将路由到下一个侦听器。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-223">The event routes to the next listener.</span></span>

  - <span data-ttu-id="e1f3d-224">执行代码以响应该事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-224">Execute code in response to the event.</span></span> <span data-ttu-id="e1f3d-225">在传递到处理程序的事件数据中将该事件标记为“已处理”，因为所执行的操作被视为不足以保证将该事件标记为“已处理”。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-225">Mark the event as handled in the event data passed to the handler, because the action taken was deemed substantial enough to warrant marking as handled.</span></span> <span data-ttu-id="e1f3d-226">该事件仍将路由到下一个侦听器，但 <xref:System.Windows.RoutedEventArgs.Handled%2A> = `true` 在其事件数据中，只有 `handledEventsToo` 侦听器才能调用进一步的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-226">The event still routes to the next listener, but with <xref:System.Windows.RoutedEventArgs.Handled%2A>=`true` in its event data, so only `handledEventsToo` listeners have the opportunity to invoke further handlers.</span></span>

<span data-ttu-id="e1f3d-227">此概念设计由前面提到的路由行为加强：更难（尽管代码或样式中仍有可能）附加处理路由事件的处理程序，即使路由上的以前处理程序已设置为也是如此 <xref:System.Windows.RoutedEventArgs.Handled%2A> `true` 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-227">This conceptual design is reinforced by the routing behavior mentioned earlier: it is more difficult (although still possible in code or styles) to attach handlers for routed events that are invoked even if a previous handler along the route has already set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span>

<span data-ttu-id="e1f3d-228">有关 <xref:System.Windows.RoutedEventArgs.Handled%2A> 路由事件的类处理的详细信息，以及有关何时适当地将路由事件标记为的建议， <xref:System.Windows.RoutedEventArgs.Handled%2A> 请参阅将[路由事件标记为已处理和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-228">For more information about <xref:System.Windows.RoutedEventArgs.Handled%2A>, class handling of routed events, and recommendations about when it is appropriate to mark a routed event as <xref:System.Windows.RoutedEventArgs.Handled%2A>, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>

<span data-ttu-id="e1f3d-229">在应用程序中，相当常见的做法是只针对引发浮升路由事件的对象来处理该事件，而根本不考虑事件的路由特征。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-229">In applications, it is quite common to just handle a bubbling routed event on the object that raised it, and not be concerned with the event's routing characteristics at all.</span></span> <span data-ttu-id="e1f3d-230">但是，在事件数据中将路由事件标记为“已处理”仍是一个不错的做法，因为这样可以防止元素树中位置更高的元素也对同一个路由事件附加了处理程序而出现意外的副作用。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-230">However, it is still a good practice to mark the routed event as handled in the event data, to prevent unanticipated side effects just in case an element that is further up the element tree also has a handler attached for that same routed event.</span></span>

<a name="class_handlers"></a>

## <a name="class-handlers"></a><span data-ttu-id="e1f3d-231">类处理程序</span><span class="sxs-lookup"><span data-stu-id="e1f3d-231">Class Handlers</span></span>

<span data-ttu-id="e1f3d-232">如果要定义从中派生的类 <xref:System.Windows.DependencyObject> ，则还可以为作为类的声明或继承的事件成员的路由事件定义和附加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-232">If you are defining a class that derives in some way from <xref:System.Windows.DependencyObject>, you can also define and attach a class handler for a routed event that is a declared or inherited event member of your class.</span></span> <span data-ttu-id="e1f3d-233">每当路由事件到达其路由中的元素实例时，都会先调用类处理程序，然后再调用附加到该类某个实例的任何实例侦听器处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-233">Class handlers are invoked before any instance listener handlers that are attached to an instance of that class, whenever a routed event reaches an element instance in its route.</span></span>

<span data-ttu-id="e1f3d-234">有些 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控件对某些路由事件具有固有的类处理。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-234">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls have inherent class handling for certain routed events.</span></span> <span data-ttu-id="e1f3d-235">路由事件可能看起来从未引发过，但实际上正对其进行类处理，如果使用某些技术，路由事件还是可以由实例处理程序进行处理。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-235">This might give the outward appearance that the routed event is not ever raised, but in reality it is being class handled, and the routed event can potentially still be handled by your instance handlers if you use certain techniques.</span></span> <span data-ttu-id="e1f3d-236">此外，许多基类和控件会公开可用来替代类处理行为的虚拟方法。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-236">Also, many base classes and controls expose virtual methods that can be used to override class handling behavior.</span></span> <span data-ttu-id="e1f3d-237">若要深入了解如何解决不需要的类处理以及如何在自定义类中定义自己的类处理，请参阅[将路由事件标记为“已处理”和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-237">For more information both on how to work around undesired class handling and on defining your own class handling in a custom class, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>

<a name="attached_events"></a>

## <a name="attached-events-in-wpf"></a><span data-ttu-id="e1f3d-238">WPF 中的附加事件</span><span class="sxs-lookup"><span data-stu-id="e1f3d-238">Attached Events in WPF</span></span>

<span data-ttu-id="e1f3d-239">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 语言还定义了一个名为附加事件的特殊类型的事件。\*\*</span><span class="sxs-lookup"><span data-stu-id="e1f3d-239">The [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] language also defines a special type of event called an *attached event*.</span></span> <span data-ttu-id="e1f3d-240">使用附加事件，可以将特定事件的处理程序添加到任意元素中。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-240">An attached event enables you to add a handler for a particular event to an arbitrary element.</span></span> <span data-ttu-id="e1f3d-241">处理事件的元素不必定义或继承附加事件，可能引发事件的对象和用来处理实例的目标也都不必将该事件定义为类成员，或将其作为类成员来“拥有”。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-241">The element handling the event need not define or inherit the attached event, and neither the object potentially raising the event nor the destination handling instance must define or otherwise "own" that event as a class member.</span></span>

<span data-ttu-id="e1f3d-242">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 输入系统广泛使用附加事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-242">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input system uses attached events extensively.</span></span> <span data-ttu-id="e1f3d-243">但是，几乎所有的附加事件都是通过基本元素转发的。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-243">However, nearly all of these attached events are forwarded through base elements.</span></span> <span data-ttu-id="e1f3d-244">输入事件随后会显示为作为基本元素类成员的等效非附加路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-244">The input events then appear as equivalent non-attached routed events that are members of the base element class.</span></span> <span data-ttu-id="e1f3d-245">例如， <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 可以通过使用来更轻松地处理基础附加事件， <xref:System.Windows.UIElement> <xref:System.Windows.UIElement.MouseDown> <xref:System.Windows.UIElement> 而不是在或代码中处理附加事件语法 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-245">For instance, the underlying attached event <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> can more easily be handled on any given <xref:System.Windows.UIElement> by using <xref:System.Windows.UIElement.MouseDown> on that <xref:System.Windows.UIElement> rather than dealing with attached event syntax either in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>

<span data-ttu-id="e1f3d-246">有关 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中附加事件的详细信息，请参阅[附加事件概述](attached-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-246">For more information about attached events in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [Attached Events Overview](attached-events-overview.md).</span></span>

<a name="Qualifying_Event_Names_in_XAML_for_Anticipated_Routing"></a>

## <a name="qualified-event-names-in-xaml"></a><span data-ttu-id="e1f3d-247">XAML 中的限定事件名称</span><span class="sxs-lookup"><span data-stu-id="e1f3d-247">Qualified Event Names in XAML</span></span>

<span data-ttu-id="e1f3d-248">为子元素所引发的路由事件附加处理程序是另一个语法用法，它与 typename.eventname 附加事件语法相似，但它并非严格意义上的附加事件用法。\*\*\*\*</span><span class="sxs-lookup"><span data-stu-id="e1f3d-248">Another syntax usage that resembles *typename*.*eventname* attached event syntax but is not strictly speaking an attached event usage is when you attach handlers for routed events that are raised by child elements.</span></span> <span data-ttu-id="e1f3d-249">可以向公用父级附加处理程序以利用事件路由，即使公用父级可能没有作为成员的相关路由事件，也是如此。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-249">You attach the handlers to a common parent, to take advantage of event routing, even though the common parent might not have the relevant routed event as a member.</span></span> <span data-ttu-id="e1f3d-250">请再次思考下面的示例：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-250">Consider this example again:</span></span>

[!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]

<span data-ttu-id="e1f3d-251">此处，添加处理程序的父元素侦听器是 <xref:System.Windows.Controls.StackPanel> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-251">Here, the parent element listener where the handler is added is a <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="e1f3d-252">但是，它将为已声明的路由事件添加处理程序，并将由 <xref:System.Windows.Controls.Button> 类引发（ <xref:System.Windows.Controls.Primitives.ButtonBase> 实际上，但可 <xref:System.Windows.Controls.Button> 通过继承实现）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-252">However, it is adding a handler for a routed event that was declared and will be raised by the <xref:System.Windows.Controls.Button> class (<xref:System.Windows.Controls.Primitives.ButtonBase> actually, but available to <xref:System.Windows.Controls.Button> through inheritance).</span></span> <span data-ttu-id="e1f3d-253"><xref:System.Windows.Controls.Button>"拥有" 事件，但路由事件系统允许任何路由事件的处理程序连接到任何 <xref:System.Windows.UIElement> 或 <xref:System.Windows.ContentElement> 实例侦听器，这些侦听器可能会为公共语言运行时（CLR）事件附加侦听器。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-253"><xref:System.Windows.Controls.Button> "owns" the event, but the routed event system permits handlers for any routed event to be attached to any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> instance listener that could otherwise attach listeners for a common language runtime (CLR) event.</span></span> <span data-ttu-id="e1f3d-254">对于这些限定的事件特性名来说，默认的 xmlns 命名空间通常是默认的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xmlns 命名空间，但是还可以为自定义路由事件指定带有前缀的命名空间。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-254">The default xmlns namespace for these qualified event attribute names is typically the default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xmlns namespace, but you can also specify prefixed namespaces for custom routed events.</span></span> <span data-ttu-id="e1f3d-255">有关 xmlns 的详细信息，请参阅 [WPF XAML 的 XAML 命名空间和命名空间映射](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-255">For more information about xmlns, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>

<a name="how_event_processing_works"></a>

## <a name="wpf-input-events"></a><span data-ttu-id="e1f3d-256">WPF 输入事件</span><span class="sxs-lookup"><span data-stu-id="e1f3d-256">WPF Input Events</span></span>

<span data-ttu-id="e1f3d-257">路由事件在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 平台中的常见应用之一是用于事件输入。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-257">One frequent application of routed events within the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] platform is for input events.</span></span> <span data-ttu-id="e1f3d-258">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，按照约定，隧道路由事件的名称以单词“Preview”开头。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-258">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], tunneling routed events names are prefixed with the word "Preview" by convention.</span></span> <span data-ttu-id="e1f3d-259">输入事件通常成对出现，一个是浮升事件，另一个是隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-259">Input events often come in pairs, with one being the bubbling event and the other being the tunneling event.</span></span> <span data-ttu-id="e1f3d-260">例如， <xref:System.Windows.ContentElement.KeyDown> 事件和 <xref:System.Windows.ContentElement.PreviewKeyDown> 事件具有相同的签名，前者是冒泡输入事件，后者是隧道输入事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-260">For example, the <xref:System.Windows.ContentElement.KeyDown> event and the <xref:System.Windows.ContentElement.PreviewKeyDown> event have the same signature, with the former being the bubbling input event and the latter being the tunneling input event.</span></span> <span data-ttu-id="e1f3d-261">偶尔，输入事件只有浮升版本，或者有可能只有直接路由版本。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-261">Occasionally, input events only have a bubbling version, or perhaps only a direct routed version.</span></span> <span data-ttu-id="e1f3d-262">在文档中，路由事件主题交叉引用具有备用路由策略的类似路由事件（如果存在这类路由事件），托管的引用页面中的相关部分阐明每个路由事件的路由策略。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-262">In the documentation, routed event topics cross-reference similar routed events with alternative routing strategies if such routed events exist, and sections in the managed reference pages clarify the routing strategy of each routed event.</span></span>

<span data-ttu-id="e1f3d-263">实现成对出现的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 输入事件，使来自输入的单个用户操作（如按鼠标按钮）按顺序引发该对中的两个路由事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-263">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input events that come in pairs are implemented so that a single user action from input, such as a mouse button press, will raise both routed events of the pair in sequence.</span></span> <span data-ttu-id="e1f3d-264">首先引发隧道事件并沿路由传播。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-264">First, the tunneling event is raised and travels its route.</span></span> <span data-ttu-id="e1f3d-265">然后引发浮升事件并沿路由传播。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-265">Then the bubbling event is raised and travels its route.</span></span> <span data-ttu-id="e1f3d-266">这两个事件以字面方式共享相同的事件数据实例，因为 <xref:System.Windows.UIElement.RaiseEvent%2A> 引发冒泡事件的实现类中的方法调用会侦听隧道事件中的事件数据，并在新引发的事件中重用它。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-266">The two events literally share the same event data instance, because the <xref:System.Windows.UIElement.RaiseEvent%2A> method call in the implementing class that raises the bubbling event listens for the event data from the tunneling event and reuses it in the new raised event.</span></span> <span data-ttu-id="e1f3d-267">具有隧道事件处理程序的侦听器首先获得将路由事件标记为“已处理”的机会（首先是类处理程序，然后是实例处理程序）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-267">Listeners with handlers for the tunneling event have the first opportunity to mark the routed event handled (class handlers first, then instance handlers).</span></span> <span data-ttu-id="e1f3d-268">如果隧道路由中的某个元素将路由事件标记为“已处理”，则会针对浮升事件发送已处理的事件数据，而且将不调用等效的浮升输入事件的附加典型处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-268">If an element along the tunneling route marked the routed event as handled, the already-handled event data is sent on for the bubbling event, and typical handlers attached for the equivalent bubbling input events will not be invoked.</span></span> <span data-ttu-id="e1f3d-269">已处理的浮升事件看起来好像尚未引发。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-269">To outward appearances it will be as if the handled bubbling event has not even been raised.</span></span> <span data-ttu-id="e1f3d-270">此处理行为对于控件合成非常有用，因为在此情况下你可能希望所有基于命中测试的输入事件或者所有基于焦点的输入事件都由最终的控件（而不是它的复合部件）报告。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-270">This handling behavior is useful for control compositing, where you might want all hit-test based input events or focus-based input events to be reported by your final control, rather than its composite parts.</span></span> <span data-ttu-id="e1f3d-271">作为可支持控件类的代码的一部分，最后一个控件元素靠近合成中的根，因此将有机会首先对隧道事件进行类处理，或者有机会将该路由事件“替换”为更针对控件的事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-271">The final control element is closer to the root in the compositing, and therefore has the opportunity to class handle the tunneling event first and perhaps to "replace" that routed event with a more control-specific event, as part of the code that backs the control class.</span></span>

<span data-ttu-id="e1f3d-272">为了说明输入事件处理的工作方式，请思考下面的输入事件示例。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-272">As an illustration of how input event processing works, consider the following input event example.</span></span> <span data-ttu-id="e1f3d-273">在下面的树插图中， `leaf element #2` 是和事件的源 `PreviewMouseDown` `MouseDown` ：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-273">In the following tree illustration, `leaf element #2` is the source of both a `PreviewMouseDown` and then a `MouseDown` event:</span></span>

![事件路由示意图](./media/routed-events-overview/input-event-routing.png)

<span data-ttu-id="e1f3d-275">事件的处理顺序如下所述：</span><span class="sxs-lookup"><span data-stu-id="e1f3d-275">The order of event processing is as follows:</span></span>

1. <span data-ttu-id="e1f3d-276">针对根元素处理 `PreviewMouseDown`（隧道）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-276">`PreviewMouseDown` (tunnel) on root element.</span></span>

2. <span data-ttu-id="e1f3d-277">针对中间元素 #1 处理 `PreviewMouseDown`（隧道）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-277">`PreviewMouseDown` (tunnel) on intermediate element #1.</span></span>

3. <span data-ttu-id="e1f3d-278">针对源元素 #2 处理 `PreviewMouseDown`（隧道）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-278">`PreviewMouseDown` (tunnel) on source element #2.</span></span>

4. <span data-ttu-id="e1f3d-279">针对源元素 #2 处理 `MouseDown`（浮升）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-279">`MouseDown` (bubble) on source element #2.</span></span>

5. <span data-ttu-id="e1f3d-280">针对中间元素 #1 处理 `MouseDown`（浮升）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-280">`MouseDown` (bubble) on intermediate element #1.</span></span>

6. <span data-ttu-id="e1f3d-281">针对根元素处理 `MouseDown`（浮升）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-281">`MouseDown` (bubble) on root element.</span></span>

<span data-ttu-id="e1f3d-282">路由事件处理程序委托提供对以下两个对象的引用：引发该事件的对象以及在其中调用处理程序的对象。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-282">A routed event handler delegate provides references to two objects: the object that raised the event and the object where the handler was invoked.</span></span> <span data-ttu-id="e1f3d-283">在其中调用处理程序的对象是由 `sender` 参数报告的对象。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-283">The object where the handler was invoked is the object reported by the `sender` parameter.</span></span> <span data-ttu-id="e1f3d-284">事件数据中的属性报告第一次引发事件的对象 <xref:System.Windows.RoutedEventArgs.Source%2A> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-284">The object where the event was first raised is reported by the <xref:System.Windows.RoutedEventArgs.Source%2A> property in the event data.</span></span> <span data-ttu-id="e1f3d-285">路由事件仍可由相同的对象引发和处理，在这种情况下， `sender` 和 <xref:System.Windows.RoutedEventArgs.Source%2A> 是相同的（事件处理示例列表中的步骤3和4就是这种情况）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-285">A routed event can still be raised and handled by the same object, in which case `sender` and <xref:System.Windows.RoutedEventArgs.Source%2A> are identical (this is the case with Steps 3 and 4 in the event processing example list).</span></span>

<span data-ttu-id="e1f3d-286">由于隧道和冒泡，父元素会接收输入事件，其中， <xref:System.Windows.RoutedEventArgs.Source%2A> 是其子元素之一。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-286">Because of tunneling and bubbling, parent elements receive input events where the <xref:System.Windows.RoutedEventArgs.Source%2A> is one of their child elements.</span></span> <span data-ttu-id="e1f3d-287">如果知道源元素是什么，则可以通过访问属性来标识源元素 <xref:System.Windows.RoutedEventArgs.Source%2A> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-287">When it is important to know what the source element is, you can identify the source element by accessing the <xref:System.Windows.RoutedEventArgs.Source%2A> property.</span></span>

<span data-ttu-id="e1f3d-288">通常，在标记输入事件后 <xref:System.Windows.RoutedEventArgs.Handled%2A> ，不会调用进一步的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-288">Usually, once the input event is marked <xref:System.Windows.RoutedEventArgs.Handled%2A>, further handlers are not invoked.</span></span> <span data-ttu-id="e1f3d-289">通常，一旦调用了用来对输入事件的含义进行特定于应用程序的逻辑处理的处理程序，就应当将输入事件标记为“已处理”。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-289">Typically, you should mark input events as handled as soon as a handler is invoked that addresses your application-specific logical handling of the meaning of the input event.</span></span>

<span data-ttu-id="e1f3d-290">这种关于状态的常规语句的例外 <xref:System.Windows.RoutedEventArgs.Handled%2A> 情况是：注册到特意忽略 <xref:System.Windows.RoutedEventArgs.Handled%2A> 事件数据状态的输入事件处理程序仍将在任一路由上调用。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-290">The exception to this general statement about <xref:System.Windows.RoutedEventArgs.Handled%2A> state is that input event handlers that are registered to deliberately ignore <xref:System.Windows.RoutedEventArgs.Handled%2A> state of the event data would still be invoked along either route.</span></span> <span data-ttu-id="e1f3d-291">有关详细信息，请参阅[预览事件](preview-events.md)或[将路由事件标记为“已处理”和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-291">For more information, see [Preview Events](preview-events.md) or [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>

<span data-ttu-id="e1f3d-292">通常，隧道事件和浮升事件之间的共享事件数据模型以及先引发隧道事件后引发浮升事件的顺序引发并非适用于所有的路由事件的概念。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-292">The shared event data model between tunneling and bubbling events, and the sequential raising of first tunneling then bubbling events, is not a concept that is generally true for all routed events.</span></span> <span data-ttu-id="e1f3d-293">该行为的实现取决于 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 输入设备选择引发和连接输入事件对的具体方式。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-293">That behavior is specifically implemented by how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input devices choose to raise and connect the input event pairs.</span></span> <span data-ttu-id="e1f3d-294">实现你自己的输入事件是一个高级方案，但是你也可以选择针对自己的输入事件遵循该模型。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-294">Implementing your own input events is an advanced scenario, but you might choose to follow that model for your own input events also.</span></span>

<span data-ttu-id="e1f3d-295">一些类选择对某些输入事件进行类处理，其目的通常是重新定义用户驱动的特定输入事件在该控件中的含义并引发新事件。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-295">Certain classes choose to class-handle certain input events, usually with the intent of redefining what a particular user-driven input event means within that control and raising a new event.</span></span> <span data-ttu-id="e1f3d-296">有关详细信息，请参阅[将路由事件标记为“已处理”和类处理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-296">For more information, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>

<span data-ttu-id="e1f3d-297">有关输入以及在典型的应用程序方案中输入和事件如何交互的详细信息，请参阅[输入概述](input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-297">For more information on input and how input and events interact in typical application scenarios, see [Input Overview](input-overview.md).</span></span>

<a name="events_styles"></a>

## <a name="eventsetters-and-eventtriggers"></a><span data-ttu-id="e1f3d-298">EventSetter 和 EventTrigger</span><span class="sxs-lookup"><span data-stu-id="e1f3d-298">EventSetters and EventTriggers</span></span>

<span data-ttu-id="e1f3d-299">在样式中，可以通过使用在标记中包含一些预声明 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 的事件处理语法 <xref:System.Windows.EventSetter> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-299">In styles, you can include some pre-declared [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] event handling syntax in the markup by using an <xref:System.Windows.EventSetter>.</span></span> <span data-ttu-id="e1f3d-300">在应用样式时，所引用的处理程序会添加到带样式的实例中。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-300">When the style is applied, the referenced handler is added to the styled instance.</span></span> <span data-ttu-id="e1f3d-301">只能 <xref:System.Windows.EventSetter> 为路由事件声明。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-301">You can declare an <xref:System.Windows.EventSetter> only for a routed event.</span></span> <span data-ttu-id="e1f3d-302">下面是一个示例。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-302">The following is an example.</span></span> <span data-ttu-id="e1f3d-303">请注意，此处引用的 `b1SetColor` 方法位于代码隐藏文件中。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-303">Note that the `b1SetColor` method referenced here is in a code-behind file.</span></span>

[!code-xaml[EventOvwSupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]

<span data-ttu-id="e1f3d-304">这里获得的优势在于，样式可能包含大量其他可应用于应用程序中任何按钮的信息，并且， <xref:System.Windows.EventSetter> 将作为该样式的一部分，即使在标记级别也是如此。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-304">The advantage gained here is that the style is likely to contain a great deal of other information that could apply to any button in your application, and having the <xref:System.Windows.EventSetter> be part of that style promotes code reuse even at the markup level.</span></span> <span data-ttu-id="e1f3d-305">此外， <xref:System.Windows.EventSetter> 抽象方法会从一般的应用程序和页标记中进一步进一步命名处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-305">Also, an <xref:System.Windows.EventSetter> abstracts method names for handlers one step further away from the general application and page markup.</span></span>

<span data-ttu-id="e1f3d-306">合并的路由事件和动画功能的另一个专用语法 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 是 <xref:System.Windows.EventTrigger> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-306">Another specialized syntax that combines the routed event and animation features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is an <xref:System.Windows.EventTrigger>.</span></span> <span data-ttu-id="e1f3d-307">与一样 <xref:System.Windows.EventSetter> ，仅路由事件可用于 <xref:System.Windows.EventTrigger> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-307">As with <xref:System.Windows.EventSetter>, only routed events may be used for an <xref:System.Windows.EventTrigger>.</span></span> <span data-ttu-id="e1f3d-308">通常， <xref:System.Windows.EventTrigger> 将声明为样式的一部分，但是 <xref:System.Windows.EventTrigger> 也可以在页级元素上声明为集合的一部分 <xref:System.Windows.FrameworkElement.Triggers%2A> ，或者在中声明 <xref:System.Windows.Controls.ControlTemplate> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-308">Typically, an <xref:System.Windows.EventTrigger> is declared as part of a style, but an <xref:System.Windows.EventTrigger> can also be declared on page-level elements as part of the <xref:System.Windows.FrameworkElement.Triggers%2A> collection, or in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="e1f3d-309"><xref:System.Windows.EventTrigger>利用，您可以指定一个 <xref:System.Windows.Media.Animation.Storyboard> 每当路由事件在其路由中到达为该事件声明的元素时运行的 <xref:System.Windows.EventTrigger> 。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-309">An <xref:System.Windows.EventTrigger> enables you to specify a <xref:System.Windows.Media.Animation.Storyboard> that runs whenever a routed event reaches an element in its route that declares an <xref:System.Windows.EventTrigger> for that event.</span></span> <span data-ttu-id="e1f3d-310"><xref:System.Windows.EventTrigger>除了处理事件并导致其启动现有情节提要外，的优点是 <xref:System.Windows.EventTrigger> 可以更好地控制情节提要及其运行时行为。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-310">The advantage of an <xref:System.Windows.EventTrigger> over just handling the event and causing it to start an existing storyboard is that an <xref:System.Windows.EventTrigger> provides better control over the storyboard and its run-time behavior.</span></span> <span data-ttu-id="e1f3d-311">有关详细信息，请参阅[在情节提要启动之后使用事件触发器来控制情节提要](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-311">For more information, see [Use Event Triggers to Control a Storyboard After It Starts](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md).</span></span>

<a name="more_about"></a>

## <a name="more-about-routed-events"></a><span data-ttu-id="e1f3d-312">有关路由事件的更多信息</span><span class="sxs-lookup"><span data-stu-id="e1f3d-312">More About Routed Events</span></span>

<span data-ttu-id="e1f3d-313">本主题主要从以下角度讨论路由事件：描述基本概念；就如何以及何时响应各种基元素和控件中已经存在的路由事件提供指南。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-313">This topic mainly discusses routed events from the perspective of describing the basic concepts and offering guidance on how and when to respond to the routed events that are already present in the various base elements and controls.</span></span> <span data-ttu-id="e1f3d-314">但是，你可以在自定义类上创建自己的路由事件以及所有必要的支持（如专用的事件数据类和委托）。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-314">However, you can create your own routed event on your custom class along with all the necessary support, such as specialized event data classes and delegates.</span></span> <span data-ttu-id="e1f3d-315">路由事件所有者可以是任何类，但路由事件必须由或派生类引发和处理 <xref:System.Windows.UIElement> 才能 <xref:System.Windows.ContentElement> 发挥作用。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-315">The routed event owner can be any class, but routed events must be raised by and handled by <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> derived classes in order to be useful.</span></span> <span data-ttu-id="e1f3d-316">有关自定义事件的详细信息，请参阅[创建自定义路由事件](how-to-create-a-custom-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="e1f3d-316">For more information about custom events, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="e1f3d-317">另请参阅</span><span class="sxs-lookup"><span data-stu-id="e1f3d-317">See also</span></span>

- <xref:System.Windows.EventManager>
- <xref:System.Windows.RoutedEvent>
- <xref:System.Windows.RoutedEventArgs>
- [<span data-ttu-id="e1f3d-318">将路由事件标记为“已处理”和“类处理”</span><span class="sxs-lookup"><span data-stu-id="e1f3d-318">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="e1f3d-319">输入概述</span><span class="sxs-lookup"><span data-stu-id="e1f3d-319">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="e1f3d-320">命令概述</span><span class="sxs-lookup"><span data-stu-id="e1f3d-320">Commanding Overview</span></span>](commanding-overview.md)
- [<span data-ttu-id="e1f3d-321">自定义依赖项属性</span><span class="sxs-lookup"><span data-stu-id="e1f3d-321">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="e1f3d-322">WPF 中的树</span><span class="sxs-lookup"><span data-stu-id="e1f3d-322">Trees in WPF</span></span>](trees-in-wpf.md)
- [<span data-ttu-id="e1f3d-323">弱事件模式</span><span class="sxs-lookup"><span data-stu-id="e1f3d-323">Weak Event Patterns</span></span>](weak-event-patterns.md)
