---
title: 延迟初始化
description: 探索 .NET 中的迟缓初始化，性能提高意味着对象创建被延迟到首次使用该对象时。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 355fa326fc19e9a50a74e21ace0a6353f5c740c5
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904229"
---
# <a name="lazy-initialization"></a><span data-ttu-id="cbfbf-103">延迟初始化</span><span class="sxs-lookup"><span data-stu-id="cbfbf-103">Lazy Initialization</span></span>
<span data-ttu-id="cbfbf-104">对象的\*\* 迟缓初始化意味着推迟创建该对象，直到它被首次使用。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="cbfbf-105">（在本主题中，术语 "*迟缓初始化*" 和 "*迟缓实例化*" 是同义词。）迟缓初始化主要用于提高性能，避免浪费计算，并降低程序内存要求。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="cbfbf-106">以下是常见方案：</span><span class="sxs-lookup"><span data-stu-id="cbfbf-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="cbfbf-107">对象创建成本高且程序可能不会使用它。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="cbfbf-108">例如，假定内存中有具有 `Orders` 属性的 `Customer` 对象，该对象包含大量 `Order` 对象，初始化这些对象需要数据库连接。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="cbfbf-109">如果用户永远不要求显示 Orders 或在计算中使用该数据，则无需使用系统内存或计算周期来创建它。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="cbfbf-110">通过使用 `Lazy<Orders>` 来声明 `Orders` 对象用于迟缓初始化，可以避免在不使用该对象时浪费系统资源。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="cbfbf-111">对象创建成本高，且希望将其创建推迟到其他高成本操作完成后。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="cbfbf-112">例如，假定程序在启动时加载多个对象实例，但是只需立即加载其中一部分。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="cbfbf-113">可以通过推迟初始化不需要的对象，直到创建所需对象，提升程序的启动性能。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="cbfbf-114">虽然可以编写自己的代码来执行迟缓初始化，但我们建议使用 <xref:System.Lazy%601>。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="cbfbf-115"><xref:System.Lazy%601> 及其相关的类型还支持线程安全并提供一致的异常传播策略。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="cbfbf-116">下表列出了 .NET Framework 版本 4 提供的在不同方案中启用迟缓初始化的类型。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="cbfbf-117">类型</span><span class="sxs-lookup"><span data-stu-id="cbfbf-117">Type</span></span>|<span data-ttu-id="cbfbf-118">说明</span><span class="sxs-lookup"><span data-stu-id="cbfbf-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="cbfbf-119">为任何类库或用户定义类型提供迟缓初始化语义的包装类。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="cbfbf-120">类似于 <xref:System.Lazy%601>，除了该包装类基于线程本地提供迟缓初始化语义。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="cbfbf-121">每个线程都可以访问自己唯一的值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="cbfbf-122">为对象的迟缓初始化提供高级 `static`（Visual Basic 中的 `Shared`）方法，无需支付类的成本。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="cbfbf-123">基本迟缓初始化</span><span class="sxs-lookup"><span data-stu-id="cbfbf-123">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="cbfbf-124">若要定义迟缓初始化类型（例如 `MyType`），使用 `Lazy<MyType>`（Visual Basic 中的 `Lazy(Of MyType)`），如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="cbfbf-125">如果没有在 <xref:System.Lazy%601> 构造函数中传入委托，则在首次访问值属性时，将使用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 创建包装类型。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="cbfbf-126">如果该类型没有无参数构造函数，则会引发运行时异常。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="cbfbf-127">在以下示例中，假定 `Orders` 是包含从数据库检索的大量 `Order` 对象的类。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="cbfbf-128">`Customer` 对象包含 `Orders` 的实例，但根据用户操作，可能不需要 `Orders` 对象的数据。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="cbfbf-129">还可以在 <xref:System.Lazy%601> 构造函数中传递委托（该委托在创建时调用包装类型上的特定构造函数重载），并执行所需的任何其他初始化步骤，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="cbfbf-130">创建迟缓对象后，在首次访问迟缓变量的 <xref:System.Lazy%601.Value%2A> 属性前，不会创建 `Orders` 的实例。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="cbfbf-131">首次访问时，会创建并返回包装类型，并将其存储起来以便将来访问。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="cbfbf-132"><xref:System.Lazy%601> 对象总是返回其初始化的相同对象或值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="cbfbf-133">因此，<xref:System.Lazy%601.Value%2A> 属性为只读。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="cbfbf-134">如果 <xref:System.Lazy%601.Value%2A> 存储了引用类型，将无法为其分配新对象。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="cbfbf-135">（但是，您可以更改其可设置的公共字段和属性的值。）如果 <xref:System.Lazy%601.Value%2A> 存储值类型，则不能修改其值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="cbfbf-136">但是，可以通过再次调用变量构造函数，使用新参数来创建新变量。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="cbfbf-137">新的迟缓实例与之前的实例一样，不会实例化 `Orders`，直到首次访问其 <xref:System.Lazy%601.Value%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="cbfbf-138">线程安全初始化</span><span class="sxs-lookup"><span data-stu-id="cbfbf-138">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="cbfbf-139">默认情况下，<xref:System.Lazy%601> 对象是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="cbfbf-140">也就是说，如果构造函数没有指定线程安全性的类型，该函数创建的 <xref:System.Lazy%601> 对象是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="cbfbf-141">在多线程方案中，访问线程安全 <xref:System.Lazy%601> 对象的 <xref:System.Lazy%601.Value%2A> 属性的第一个线程会为所有线程上的所有后续访问对其初始化，且所有线程共享相同的数据。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="cbfbf-142">因此，哪个线程初始化对象并不重要，争用条件是良性的。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="cbfbf-143">可以通过使用异常缓存将此一致性扩展到错误条件。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="cbfbf-144">有关详细信息，请参阅下一部分[迟缓对象的异常](lazy-initialization.md#ExceptionsInLazyObjects)。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="cbfbf-145">以下示例演示了相同的 `Lazy<int>` 实例对于三个单独的线程具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="cbfbf-146">如果每个线程需要单独的数据，使用 <xref:System.Threading.ThreadLocal%601> 类型，如本主题后面所述。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="cbfbf-147">一些 <xref:System.Lazy%601> 构造函数具有名为 `isThreadSafe` 的布尔参数，该参数用于指定是否从多线程访问 <xref:System.Lazy%601.Value%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="cbfbf-148">如果想要仅从一个线程访问属性，则传入 `false` 以获取适度的性能优势。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="cbfbf-149">如果想要从多线程访问属性，则传入 `true` 以指示 <xref:System.Lazy%601> 实例正确处理争用条件（初始化时一个线程引发异常）。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="cbfbf-150">一些 <xref:System.Lazy%601> 构造函数具有命名为 `mode` 的 <xref:System.Threading.LazyThreadSafetyMode> 参数。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="cbfbf-151">这些构造函数可提供其他线程安全模式。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="cbfbf-152">下表显示了 <xref:System.Lazy%601> 对象的线程安全性如何受到指定线程安全性的构造函数参数的影响。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="cbfbf-153">每个构造函最多具有一个此类参数。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="cbfbf-154">对象的线程安全性</span><span class="sxs-lookup"><span data-stu-id="cbfbf-154">Thread safety of the object</span></span>|<span data-ttu-id="cbfbf-155">`LazyThreadSafetyMode``mode`参数</span><span class="sxs-lookup"><span data-stu-id="cbfbf-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="cbfbf-156">布尔 `isThreadSafe` 参数</span><span class="sxs-lookup"><span data-stu-id="cbfbf-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="cbfbf-157">没有线程安全性参数</span><span class="sxs-lookup"><span data-stu-id="cbfbf-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="cbfbf-158">完全线程安全；一次只有一个线程尝试初始化值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="cbfbf-159">是的。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-159">Yes.</span></span>|  
|<span data-ttu-id="cbfbf-160">非线程安全。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="cbfbf-161">不适用。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-161">Not applicable.</span></span>|  
|<span data-ttu-id="cbfbf-162">完全线程安全；线程争用以初始化值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="cbfbf-163">不适用。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-163">Not applicable.</span></span>|<span data-ttu-id="cbfbf-164">不适用。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="cbfbf-165">如此表所示，为 `mode` 参数指定 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 与为 `isThreadSafe` 参数指定 `true` 相同，并且指定 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> 与指定 `false` 相同。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="cbfbf-166">指定 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> 允许多个线程尝试初始化 <xref:System.Lazy%601> 实例。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="cbfbf-167">只有一个线程可以赢得此争用，而其他所有线程都将接收成功的线程初始化的值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="cbfbf-168">如果在初始化期间，某个线程引发了异常，则此线程不会接收成功的线程设置的值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="cbfbf-169">不会缓存异常，因此随后尝试访问 <xref:System.Lazy%601.Value%2A> 属性可能会导致初始化成功。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="cbfbf-170">这与其他模式中的异常处理方式不同，下面将对此进行描述。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="cbfbf-171">有关详细信息，请参见 <xref:System.Threading.LazyThreadSafetyMode> 枚举。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="cbfbf-172">迟缓对象的异常</span><span class="sxs-lookup"><span data-stu-id="cbfbf-172">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="cbfbf-173">如前所述，<xref:System.Lazy%601> 对象始终返回其初始化的相同对象或值，因此 <xref:System.Lazy%601.Value%2A> 属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="cbfbf-174">如果启用异常缓存，则此永久性还会扩展到异常行为。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="cbfbf-175">如果延迟初始化的对象已启用异常缓存并在第一次访问该属性时从其初始化方法引发异常 <xref:System.Lazy%601.Value%2A> ，则每次访问该属性的尝试都会引发相同的异常 <xref:System.Lazy%601.Value%2A> 。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="cbfbf-176">也就是说，即使在多线程方案中，包装类型的构造函数也绝不会被重新调用。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="cbfbf-177">因此，<xref:System.Lazy%601> 对象不能在一次访问时引发异常，并在随后访问时返回值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="cbfbf-178">当使用任何采用初始化方法（`valueFactory` 参数）的 <xref:System.Lazy%601?displayProperty=nameWithType> 构造函数时，都会启用异常缓存；例如，当使用 `Lazy(T)(Func(T))` 构造函数时，会启用异常缓存。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="cbfbf-179">如果构造函数还使用 <xref:System.Threading.LazyThreadSafetyMode> 值（`mode` 参数），请指定 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 或 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cbfbf-180">指定初始化方法可启用这两种模式的异常缓存。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="cbfbf-181">初始化方法非常简单。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-181">The initialization method can be very simple.</span></span> <span data-ttu-id="cbfbf-182">例如，它可能会调用的无参数构造函数 `T` ： `new Lazy<Contents>(() => new Contents(), mode)` 在 c # 中，或 `New Lazy(Of Contents)(Function() New Contents())` 在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="cbfbf-183">如果使用不指定初始化方法的 <xref:System.Lazy%601?displayProperty=nameWithType> 构造函数，则不会缓存 `T` 无参数构造函数引发的异常。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="cbfbf-184">有关详细信息，请参见 <xref:System.Threading.LazyThreadSafetyMode> 枚举。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="cbfbf-185">如果通过将 `isThreadSafe` 构造函数参数设置为 `false` 或将 `mode` 构造函数参数设置为 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> 来创建 <xref:System.Lazy%601> 对象，则必须从单个线程访问 <xref:System.Lazy%601> 对象或提供你自己的同步。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="cbfbf-186">这适用于对象的所有方面，包括异常缓存。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="cbfbf-187">如上一节所述，通过指定 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> 创建的 <xref:System.Lazy%601> 对象会以不同方式处理异常。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="cbfbf-188">通过 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>，多个线程可以通过争用来初始化 <xref:System.Lazy%601> 实例。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="cbfbf-189">在这种情况下，不会缓存异常，并且可以继续尝试访问 <xref:System.Lazy%601.Value%2A> 属性，直到初始化成功。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="cbfbf-190">下表总结了 <xref:System.Lazy%601> 构造函数控制异常缓存的方式。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="cbfbf-191">构造函数</span><span class="sxs-lookup"><span data-stu-id="cbfbf-191">Constructor</span></span>|<span data-ttu-id="cbfbf-192">线程安全性</span><span class="sxs-lookup"><span data-stu-id="cbfbf-192">Thread safety mode</span></span>|<span data-ttu-id="cbfbf-193">使用初始化方法</span><span class="sxs-lookup"><span data-stu-id="cbfbf-193">Uses initialization method</span></span>|<span data-ttu-id="cbfbf-194">异常被缓存</span><span class="sxs-lookup"><span data-stu-id="cbfbf-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="cbfbf-195">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="cbfbf-195">Lazy(T)()</span></span>|<span data-ttu-id="cbfbf-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="cbfbf-197">否</span><span class="sxs-lookup"><span data-stu-id="cbfbf-197">No</span></span>|<span data-ttu-id="cbfbf-198">否</span><span class="sxs-lookup"><span data-stu-id="cbfbf-198">No</span></span>|  
|<span data-ttu-id="cbfbf-199">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="cbfbf-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="cbfbf-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="cbfbf-201">是</span><span class="sxs-lookup"><span data-stu-id="cbfbf-201">Yes</span></span>|<span data-ttu-id="cbfbf-202">是</span><span class="sxs-lookup"><span data-stu-id="cbfbf-202">Yes</span></span>|  
|<span data-ttu-id="cbfbf-203">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="cbfbf-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) 或 `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="cbfbf-205">否</span><span class="sxs-lookup"><span data-stu-id="cbfbf-205">No</span></span>|<span data-ttu-id="cbfbf-206">否</span><span class="sxs-lookup"><span data-stu-id="cbfbf-206">No</span></span>|  
|<span data-ttu-id="cbfbf-207">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="cbfbf-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) 或 `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="cbfbf-209">是</span><span class="sxs-lookup"><span data-stu-id="cbfbf-209">Yes</span></span>|<span data-ttu-id="cbfbf-210">是</span><span class="sxs-lookup"><span data-stu-id="cbfbf-210">Yes</span></span>|  
|<span data-ttu-id="cbfbf-211">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="cbfbf-212">用户指定</span><span class="sxs-lookup"><span data-stu-id="cbfbf-212">User-specified</span></span>|<span data-ttu-id="cbfbf-213">否</span><span class="sxs-lookup"><span data-stu-id="cbfbf-213">No</span></span>|<span data-ttu-id="cbfbf-214">否</span><span class="sxs-lookup"><span data-stu-id="cbfbf-214">No</span></span>|  
|<span data-ttu-id="cbfbf-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="cbfbf-216">用户指定</span><span class="sxs-lookup"><span data-stu-id="cbfbf-216">User-specified</span></span>|<span data-ttu-id="cbfbf-217">是</span><span class="sxs-lookup"><span data-stu-id="cbfbf-217">Yes</span></span>|<span data-ttu-id="cbfbf-218">如果用户指定 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> 则为 no；否则为 yes。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="cbfbf-219">实现迟缓初始化的属性</span><span class="sxs-lookup"><span data-stu-id="cbfbf-219">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="cbfbf-220">若要通过使用迟缓初始化实现公共属性，则将该属性的支持字段定义为 <xref:System.Lazy%601>，并从该属性的 `get` 访问器返回 <xref:System.Lazy%601.Value%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="cbfbf-221"><xref:System.Lazy%601.Value%2A> 属性是只读的；因此，将其公开的属性没有 `set` 访问器。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="cbfbf-222">如果需要由 <xref:System.Lazy%601> 对象支持的读取/写入属性，则 `set` 访问器必须创建一个新的 <xref:System.Lazy%601> 对象并将其分配到后备存储。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="cbfbf-223">`set` 访问器必须创建一个 lambda 表达式（该表达式返回传递给 `set` 访问器的新属性值），并将该 lambda 表达式传递给新的 <xref:System.Lazy%601> 对象的构造函数。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="cbfbf-224">下一次访问 <xref:System.Lazy%601.Value%2A> 属性将导致新 <xref:System.Lazy%601> 的初始化，并且其 <xref:System.Lazy%601.Value%2A> 属性此后会返回已分配给该属性的新值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="cbfbf-225">进行此复杂安排的原因是保留内置于 <xref:System.Lazy%601> 的多线程保护。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="cbfbf-226">否则，属性访问器必须缓存由 <xref:System.Lazy%601.Value%2A> 属性返回的第一个值并仅修改缓存值，而用户必须编写自己的线程安全代码才能执行此操作。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="cbfbf-227">因为由 <xref:System.Lazy%601> 对象支持的读取/写入属性需要其他初始化，因此此性能可能不可接受。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="cbfbf-228">此外，可能需要额外的协调以避免资源库与 getter 之间的争用条件，具体取决于特定方案。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="cbfbf-229">线程本地迟缓初始化</span><span class="sxs-lookup"><span data-stu-id="cbfbf-229">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="cbfbf-230">在一些多线程方案中，可能需要为每个线程提供其专用数据。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="cbfbf-231">此类数据称为线程本地数据\*\*。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="cbfbf-232">在 .NET Framework 版本 3.5 及先前版本中，可以将 `ThreadStatic` 属性应用到静态变量，使其成为本地线程。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="cbfbf-233">然而，使用 `ThreadStatic` 属性可能会导致细微的错误。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="cbfbf-234">例如，即使是基本的初始化语句也将导致仅在访问其的首个线程上初始化变量，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="cbfbf-235">在所有其他线程上，变量将通过使用其默认值（零）进行初始化。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="cbfbf-236">作为 .NET Framework 版本 4 中的替代方法，可以使用 <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> 类型创建一个基于实例的线程本地变量，该变量由你提供的 <xref:System.Action%601> 委托在所有线程上进行初始化。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="cbfbf-237">在以下示例中，访问 `counter` 的所有线程都将其启动值视为 1。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="cbfbf-238"><xref:System.Threading.ThreadLocal%601> 包装其对象的方式与 <xref:System.Lazy%601> 非常相似，但存在以下主要区别：</span><span class="sxs-lookup"><span data-stu-id="cbfbf-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="cbfbf-239">每个线程都通过使用其自己的专有数据来初始化线程本地变量，这些数据不能从其他线程访问。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="cbfbf-240"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> 属性可以读取和写入，并且可以修改任意次数。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="cbfbf-241">这可能会影响异常传播，例如，一个 `get` 操作可能会引发异常，但下一个操作可能会成功初始化该值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="cbfbf-242">如果没有提供初始化委托，<xref:System.Threading.ThreadLocal%601> 将通过使用该类型的默认值初始化其包装类型。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="cbfbf-243">在这一方面，<xref:System.Threading.ThreadLocal%601> 与 <xref:System.ThreadStaticAttribute> 属性一致。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="cbfbf-244">以下示例显示了每个访问 `ThreadLocal<int>` 实例的线程都将获取其数据的唯一副本。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="cbfbf-245">Parallel.For 和 ForEach 中的线程本地变量</span><span class="sxs-lookup"><span data-stu-id="cbfbf-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="cbfbf-246">当使用 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 方法或 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 方法来并行循环访问数据源时，可以使用包含针对线程本地数据的内置支持的重载。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="cbfbf-247">在这些方法中，通过使用本地委托来创建、访问和清理数据，可以实现线程本地性。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="cbfbf-248">有关详细信息，请参阅[如何：编写具有线程本地变量的 Parallel.For 循环](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)和[如何：编写具有分区本地变量的 Parallel.ForEach 循环](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md)。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="cbfbf-249">将迟缓初始化用于开销较低的方案</span><span class="sxs-lookup"><span data-stu-id="cbfbf-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="cbfbf-250">在必须迟缓初始化大量对象的方案中，你可能会认为在 <xref:System.Lazy%601> 中包装每个对象需要过多的内存或过多的计算资源。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="cbfbf-251">或者，你可能对如何公开迟缓初始化有严格要求。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="cbfbf-252">在这种情况下，可以使用 <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> 类的 `static`（Visual Basic 中的 `Shared`）方法来迟缓初始化每个对象，而不会将其包装在 <xref:System.Lazy%601> 的实例中。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="cbfbf-253">在以下示例中，假定你仅具有所需的迟缓初始化的单个`Order` 对象，而不是将整个 `Orders` 对象包装在一个 <xref:System.Lazy%601> 对象中。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="cbfbf-254">在此示例中，请注意循环的每次迭代都会调用初始化过程。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="cbfbf-255">在多线程方案中，所有线程都会知道调用初始化过程的第一个线程的值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="cbfbf-256">后续线程也会调用初始化过程，但不会使用其值。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="cbfbf-257">如果这种潜在的争用条件是不可接受的，请使用 <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> 的重载，获取布尔参数和同步对象。</span><span class="sxs-lookup"><span data-stu-id="cbfbf-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cbfbf-258">另请参阅</span><span class="sxs-lookup"><span data-stu-id="cbfbf-258">See also</span></span>

- [<span data-ttu-id="cbfbf-259">托管线程处理基本知识</span><span class="sxs-lookup"><span data-stu-id="cbfbf-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="cbfbf-260">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="cbfbf-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="cbfbf-261">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="cbfbf-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="cbfbf-262">如何：执行对象的延迟初始化</span><span class="sxs-lookup"><span data-stu-id="cbfbf-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
