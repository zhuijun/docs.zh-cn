---
title: 会话、实例化和并发
description: 了解会话、实例化和并发性，以及如何使用它们以及 WFC 中它们之间的交互。
ms.date: 03/30/2017
ms.assetid: 50797a3b-7678-44ed-8138-49ac1602f35b
ms.openlocfilehash: 41eef5a962c702eebd6b9a34607b542ec6bbd97b
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246540"
---
# <a name="sessions-instancing-and-concurrency"></a><span data-ttu-id="7e2f9-103">会话、实例化和并发</span><span class="sxs-lookup"><span data-stu-id="7e2f9-103">Sessions, Instancing, and Concurrency</span></span>
<span data-ttu-id="7e2f9-104">\*\* “会话”是在两个终结点之间发送的所有消息的一种相互关系。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-104">A *session* is a correlation of all messages sent between two endpoints.</span></span> <span data-ttu-id="7e2f9-105">\*\* “实例化”是指对用户定义的服务对象以及与其相关的 <xref:System.ServiceModel.InstanceContext> 对象的生存期的控制。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-105">*Instancing* refers to controlling the lifetime of user-defined service objects and their related <xref:System.ServiceModel.InstanceContext> objects.</span></span> <span data-ttu-id="7e2f9-106">\*\* “并发”一词是指对 <xref:System.ServiceModel.InstanceContext> 中同时执行的线程数量的控制。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-106">*Concurrency* is the term given to the control of the number of threads executing in an <xref:System.ServiceModel.InstanceContext> at the same time.</span></span>  
  
 <span data-ttu-id="7e2f9-107">本主题描述这些设置、它们的使用方法以及它们之间的各种交互作用。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-107">This topic describes these settings, how to use them, and the various interactions between them.</span></span>  
  
## <a name="sessions"></a><span data-ttu-id="7e2f9-108">会话</span><span class="sxs-lookup"><span data-stu-id="7e2f9-108">Sessions</span></span>  
 <span data-ttu-id="7e2f9-109">当服务协定将 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 属性设置为 <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType>时，该协定表示所有调用（即，支持调用的基础消息交换）都必须是同一个对话的一部分。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-109">When a service contract sets the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType>, that contract is saying that all calls (that is, the underlying message exchanges that support the calls) must be part of the same conversation.</span></span> <span data-ttu-id="7e2f9-110">如果某个协定指定它允许使用会话但不要求使用会话，则客户端可以进行连接，并选择建立会话或不建立会话。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-110">If a contract specifies that it allows sessions but does not require one, clients can connect and either establish a session or not.</span></span> <span data-ttu-id="7e2f9-111">如果会话结束，然后在同一个基于会话的通道上发送消息，将会引发异常。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-111">If the session ends and a message is sent over the same session-based channel an exception is thrown.</span></span>  
  
 <span data-ttu-id="7e2f9-112">WCF 会话具有以下主要概念功能：</span><span class="sxs-lookup"><span data-stu-id="7e2f9-112">WCF sessions have the following main conceptual features:</span></span>  
  
- <span data-ttu-id="7e2f9-113">它们由调用应用程序显式启动和终止。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-113">They are explicitly initiated and terminated by the calling application.</span></span>  
  
- <span data-ttu-id="7e2f9-114">会话期间传递的消息按照接收消息的顺序进行处理。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-114">Messages delivered during a session are processed in the order in which they are received.</span></span>  
  
- <span data-ttu-id="7e2f9-115">会话将一组消息相互关联，从而形成对话。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-115">Sessions correlate a group of messages into a conversation.</span></span> <span data-ttu-id="7e2f9-116">该关联的含义是抽象的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-116">The meaning of that correlation is an abstraction.</span></span> <span data-ttu-id="7e2f9-117">例如，一个基于会话的通道可能会根据共享网络连接来关联消息，而另一个基于会话的通道可能会根据消息正文中的共享标记来关联消息。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-117">For instance, one session-based channel may correlate messages based on a shared network connection while another session-based channel may correlate messages based on a shared tag in the message body.</span></span> <span data-ttu-id="7e2f9-118">可以从会话派生的功能取决于关联的性质。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-118">The features that can be derived from the session depend on the nature of the correlation.</span></span>  
  
- <span data-ttu-id="7e2f9-119">没有与 WCF 会话相关联的常规数据存储区。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-119">There is no general data store associated with a WCF session.</span></span>  
  
 <span data-ttu-id="7e2f9-120">如果你熟悉 <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> ASP.NET 应用程序中的类以及它提供的功能，你可能会注意到这种类型的会话和 WCF 会话之间存在以下差异：</span><span class="sxs-lookup"><span data-stu-id="7e2f9-120">If you are familiar with the <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> class in ASP.NET applications and the functionality it provides, you might notice the following differences between that kind of session and WCF sessions:</span></span>  
  
- <span data-ttu-id="7e2f9-121">ASP.NET 会话始终由服务器启动。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-121">ASP.NET sessions are always server-initiated.</span></span>  
  
- <span data-ttu-id="7e2f9-122">ASP.NET 会话是隐式无序的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-122">ASP.NET sessions are implicitly unordered.</span></span>  
  
- <span data-ttu-id="7e2f9-123">ASP.NET 会话提供跨请求的常规数据存储机制。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-123">ASP.NET sessions provide a general data storage mechanism across requests.</span></span>  
  
 <span data-ttu-id="7e2f9-124">客户端应用程序和服务应用程序以不同方式与会话交互。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-124">Client applications and service applications interact with sessions in different ways.</span></span> <span data-ttu-id="7e2f9-125">客户端应用程序启动会话，然后接收并处理在该会话内发送的消息。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-125">Client applications initiate sessions and then receive and process the messages sent within the session.</span></span> <span data-ttu-id="7e2f9-126">服务应用程序可以将会话用作扩展点，以添加其他行为。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-126">Service applications can use sessions as an extensibility point to add additional behavior.</span></span> <span data-ttu-id="7e2f9-127">通过直接使用 <xref:System.ServiceModel.InstanceContext> 或实现一个自定义实例上下文提供程序，可以做到这一点。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-127">This is done by working directly with the <xref:System.ServiceModel.InstanceContext> or implementing a custom instance context provider.</span></span>  
  
## <a name="instancing"></a><span data-ttu-id="7e2f9-128">实例化</span><span class="sxs-lookup"><span data-stu-id="7e2f9-128">Instancing</span></span>  
 <span data-ttu-id="7e2f9-129">实例化行为（使用 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 属性进行设置）控制如何创建 <xref:System.ServiceModel.InstanceContext> 以响应传入的消息。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-129">The instancing behavior (set by using the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property) controls how the <xref:System.ServiceModel.InstanceContext> is created in response to incoming messages.</span></span> <span data-ttu-id="7e2f9-130">默认情况下，每个 <xref:System.ServiceModel.InstanceContext> 都与一个用户定义服务对象相关联，因此（在默认情况下）设置 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 属性也可以控制用户定义服务对象的实例化。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-130">By default, each <xref:System.ServiceModel.InstanceContext> is associated with one user-defined service object, so (in the default case) setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property also controls the instancing of user-defined service objects.</span></span> <span data-ttu-id="7e2f9-131"><xref:System.ServiceModel.InstanceContextMode> 枚举定义了实例化模式。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-131">The <xref:System.ServiceModel.InstanceContextMode> enumeration defines the instancing modes.</span></span>  
  
 <span data-ttu-id="7e2f9-132">可以使用下列实例化模式：</span><span class="sxs-lookup"><span data-stu-id="7e2f9-132">The following instancing modes are available:</span></span>  
  
- <span data-ttu-id="7e2f9-133"><xref:System.ServiceModel.InstanceContextMode.PerCall>：为每个客户端请求创建一个新的 <xref:System.ServiceModel.InstanceContext> （以及相应的服务对象）。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-133"><xref:System.ServiceModel.InstanceContextMode.PerCall>: A new <xref:System.ServiceModel.InstanceContext> (and therefore service object) is created for each client request.</span></span>  
  
- <span data-ttu-id="7e2f9-134"><xref:System.ServiceModel.InstanceContextMode.PerSession>：为每个新的客户端会话创建一个新的 <xref:System.ServiceModel.InstanceContext> （以及相应的服务对象），并在该会话的生存期内对其进行维护（这需要使用支持会话的绑定）。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-134"><xref:System.ServiceModel.InstanceContextMode.PerSession>: A new <xref:System.ServiceModel.InstanceContext> (and therefore service object) is created for each new client session and maintained for the lifetime of that session (this requires a binding that supports sessions).</span></span>  
  
- <span data-ttu-id="7e2f9-135"><xref:System.ServiceModel.InstanceContextMode.Single>：单个 <xref:System.ServiceModel.InstanceContext> （以及相应的服务对象）处理应用程序生存期内的所有客户端请求。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-135"><xref:System.ServiceModel.InstanceContextMode.Single>: A single <xref:System.ServiceModel.InstanceContext> (and therefore service object) handles all client requests for the lifetime of the application.</span></span>  
  
 <span data-ttu-id="7e2f9-136">下面的代码示例演示 <xref:System.ServiceModel.InstanceContextMode> 的默认值（在服务类上显式设置了 <xref:System.ServiceModel.InstanceContextMode.PerSession> ）。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-136">The following code example shows the default <xref:System.ServiceModel.InstanceContextMode> value, <xref:System.ServiceModel.InstanceContextMode.PerSession> being explicitly set on a service class.</span></span>  
  
```csharp  
[ServiceBehavior(InstanceContextMode=InstanceContextMode.PerSession)]
public class CalculatorService : ICalculatorInstance
{
    ...  
}  
```  
  
 <span data-ttu-id="7e2f9-137"><xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 属性控制释放 <xref:System.ServiceModel.InstanceContext> 的频率，而 <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A?displayProperty=nameWithType> 属性则控制释放服务对象的时间。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-137">And while the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property controls how often the <xref:System.ServiceModel.InstanceContext> is released, the <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A?displayProperty=nameWithType> properties control when the service object is released.</span></span>  
  
### <a name="well-known-singleton-services"></a><span data-ttu-id="7e2f9-138">已知的单一实例服务</span><span class="sxs-lookup"><span data-stu-id="7e2f9-138">Well-Known Singleton Services</span></span>  
 <span data-ttu-id="7e2f9-139">有时，单个实例服务对象的变体是有用的：您可以自己创建一个服务对象，然后创建使用该对象的服务主机。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-139">One variation on single instance service objects is sometimes useful: you can create a service object yourself and create the service host using that object.</span></span> <span data-ttu-id="7e2f9-140">为此，您还必须将 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 属性设置为 <xref:System.ServiceModel.InstanceContextMode.Single> ，否则在打开该服务主机时将引发异常。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-140">To do so, you must also set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.Single> or an exception is thrown when the service host is opened.</span></span>  
  
 <span data-ttu-id="7e2f9-141">可使用 <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29> 构造函数创建此类服务。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-141">Use the <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29> constructor to create such a service.</span></span> <span data-ttu-id="7e2f9-142">当您希望提供一个特定的对象实例供单一实例服务使用时，可以使用它作为实现自定义 <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> 的替代方法。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-142">It provides an alternative to implementing a custom <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> when you wish to provide a specific object instance for use by a singleton service.</span></span> <span data-ttu-id="7e2f9-143">当服务实现类型难以构造时（例如，如果它不实现无参数的公共构造函数），可以使用此重载。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-143">You can use this overload when your service implementation type is difficult to construct (for example, if it does not implement a parameterless public constructor).</span></span>  
  
 <span data-ttu-id="7e2f9-144">请注意，当向此构造函数提供对象时，一些与 Windows Communication Foundation （WCF）实例化行为相关的功能的工作方式有所不同。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-144">Note that when an object is provided to this constructor, some features related to the Windows Communication Foundation (WCF) instancing behavior work differently.</span></span> <span data-ttu-id="7e2f9-145">例如，在提供单一实例对象实例时，调用 <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> 没有任何效果。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-145">For example, calling <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> has no effect when a singleton object instance is provided.</span></span> <span data-ttu-id="7e2f9-146">同样，其他任何实例释放机制也都会被忽略。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-146">Similarly, any other instance-release mechanism is ignored.</span></span> <span data-ttu-id="7e2f9-147"><xref:System.ServiceModel.ServiceHost> 的行为总是像对于所有操作都将 <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> 属性设置为 <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> 一样。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-147">The <xref:System.ServiceModel.ServiceHost> always behaves as if the <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> for all operations.</span></span>  
  
### <a name="sharing-instancecontext-objects"></a><span data-ttu-id="7e2f9-148">共享 InstanceContext 对象</span><span class="sxs-lookup"><span data-stu-id="7e2f9-148">Sharing InstanceContext Objects</span></span>  
 <span data-ttu-id="7e2f9-149">通过自己执行关联，您还可以控制将哪个有会话通道或调用与哪个 <xref:System.ServiceModel.InstanceContext> 对象相关联。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-149">You can also control which sessionful channel or call is associated with which <xref:System.ServiceModel.InstanceContext> object by performing that association yourself.</span></span>  
  
## <a name="concurrency"></a><span data-ttu-id="7e2f9-150">并发</span><span class="sxs-lookup"><span data-stu-id="7e2f9-150">Concurrency</span></span>  
 <span data-ttu-id="7e2f9-151">并发是对 <xref:System.ServiceModel.InstanceContext> 中在任一时刻处于活动状态的线程数量的控制。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-151">Concurrency is the control of the number of threads active in an <xref:System.ServiceModel.InstanceContext> at any one time.</span></span> <span data-ttu-id="7e2f9-152">此控制是通过将 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> 与 <xref:System.ServiceModel.ConcurrencyMode> 枚举结合使用来实现的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-152">This is controlled by using the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> with the <xref:System.ServiceModel.ConcurrencyMode> enumeration.</span></span>  
  
 <span data-ttu-id="7e2f9-153">有以下三种可用的并发模式：</span><span class="sxs-lookup"><span data-stu-id="7e2f9-153">The following three concurrency modes are available:</span></span>  
  
- <span data-ttu-id="7e2f9-154"><xref:System.ServiceModel.ConcurrencyMode.Single>：最多允许每个实例上下文同时拥有一个对该实例上下文中的消息进行处理的线程。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-154"><xref:System.ServiceModel.ConcurrencyMode.Single>: Each instance context is allowed to have a maximum of one thread processing messages in the instance context at a time.</span></span> <span data-ttu-id="7e2f9-155">其他希望使用同一个实例上下文的线程必须一直阻塞，直到原始线程退出该实例上下文为止。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-155">Other threads wishing to use the same instance context must block until the original thread exits the instance context.</span></span>  
  
- <span data-ttu-id="7e2f9-156"><xref:System.ServiceModel.ConcurrencyMode.Multiple>：每个服务实例都可以拥有多个同时处理消息的线程。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-156"><xref:System.ServiceModel.ConcurrencyMode.Multiple>: Each service instance can have multiple threads processing messages concurrently.</span></span> <span data-ttu-id="7e2f9-157">若要使用此并发模式，服务实现必须是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-157">The service implementation must be thread-safe to use this concurrency mode.</span></span>  
  
- <span data-ttu-id="7e2f9-158"><xref:System.ServiceModel.ConcurrencyMode.Reentrant>：每个服务实例一次只能处理一个消息，但可以接受可重入的操作调用。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-158"><xref:System.ServiceModel.ConcurrencyMode.Reentrant>: Each service instance processes one message at a time, but accepts re-entrant operation calls.</span></span> <span data-ttu-id="7e2f9-159">服务仅在通过 WCF 客户端对象调用时接受这些调用。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-159">The service only accepts these calls when it is calling out through a WCF client object.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7e2f9-160">理解和开发能够安全地使用多个线程的代码可能比较困难。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-160">Understanding and developing code that safely uses more than one thread can be difficult to write successfully.</span></span> <span data-ttu-id="7e2f9-161">在使用 <xref:System.ServiceModel.ConcurrencyMode.Multiple> 或 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> 值之前，应确保已针对这些模式对服务进行了适当设计。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-161">Before using <xref:System.ServiceModel.ConcurrencyMode.Multiple> or <xref:System.ServiceModel.ConcurrencyMode.Reentrant> values, ensure that your service is properly designed for these modes.</span></span> <span data-ttu-id="7e2f9-162">有关详细信息，请参阅 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-162">For more information, see <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>.</span></span>  
  
 <span data-ttu-id="7e2f9-163">并发的使用与实例化模式有关。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-163">The use of concurrency is related to the instancing mode.</span></span> <span data-ttu-id="7e2f9-164">在 <xref:System.ServiceModel.InstanceContextMode.PerCall> 实例化中，并发性不相关，因为每条消息都由一个新的处理， <xref:System.ServiceModel.InstanceContext> 因此，中的每个线程都不会处于活动状态 <xref:System.ServiceModel.InstanceContext> 。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-164">In <xref:System.ServiceModel.InstanceContextMode.PerCall> instancing, concurrency is not relevant, because each message is processed by a new <xref:System.ServiceModel.InstanceContext> and, therefore, never more than one thread is active in the <xref:System.ServiceModel.InstanceContext>.</span></span>  
  
 <span data-ttu-id="7e2f9-165">下面的代码示例演示如何将 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 属性设置为 <xref:System.ServiceModel.ConcurrencyMode.Multiple>。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-165">The following code example demonstrates setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> property to <xref:System.ServiceModel.ConcurrencyMode.Multiple>.</span></span>  
  
```csharp
[ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple, InstanceContextMode = InstanceContextMode.Single)]
public class CalculatorService : ICalculatorConcurrency
{
    ...  
}  
```  
  
## <a name="sessions-interact-with-instancecontext-settings"></a><span data-ttu-id="7e2f9-166">会话与 InstanceContext 设置进行交互</span><span class="sxs-lookup"><span data-stu-id="7e2f9-166">Sessions Interact with InstanceContext Settings</span></span>  
 <span data-ttu-id="7e2f9-167">会话和 <xref:System.ServiceModel.InstanceContext> 根据协定中 <xref:System.ServiceModel.SessionMode> 枚举的值和服务实现上的 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 属性的组合进行交互，该组合控制着通道和特定服务对象之间的联系。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-167">Sessions and <xref:System.ServiceModel.InstanceContext> interact depending upon the combination of the value of the <xref:System.ServiceModel.SessionMode> enumeration in a contract and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property on the service implementation, which controls the association between channels and specific service objects.</span></span>  
  
 <span data-ttu-id="7e2f9-168">下表显示了在给定服务的 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 属性值和 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 属性值组合的情况下，支持会话或不支持会话的传入通道的结果。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-168">The following table shows the result of an incoming channel either supporting sessions or not supporting sessions given a service's combination of the values of the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property.</span></span>  
  
|<span data-ttu-id="7e2f9-169">InstanceContextMode 值</span><span class="sxs-lookup"><span data-stu-id="7e2f9-169">InstanceContextMode value</span></span>|<xref:System.ServiceModel.SessionMode.Required>|<xref:System.ServiceModel.SessionMode.Allowed>|<xref:System.ServiceModel.SessionMode.NotAllowed>|  
|-------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<span data-ttu-id="7e2f9-170">PerCall</span><span class="sxs-lookup"><span data-stu-id="7e2f9-170">PerCall</span></span>|<span data-ttu-id="7e2f9-171">-会话通道的行为：会话和 <xref:System.ServiceModel.InstanceContext> 每个调用。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-171">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each call.</span></span><br /><span data-ttu-id="7e2f9-172">-无会话通道的行为：将引发异常。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-172">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="7e2f9-173">-会话通道的行为：会话和 <xref:System.ServiceModel.InstanceContext> 每个调用。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-173">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each call.</span></span><br /><span data-ttu-id="7e2f9-174">-无会话通道的行为： <xref:System.ServiceModel.InstanceContext> 每个调用的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-174">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|<span data-ttu-id="7e2f9-175">-会话通道的行为：将引发异常。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-175">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="7e2f9-176">-无会话通道的行为： <xref:System.ServiceModel.InstanceContext> 每个调用的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-176">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|  
|<span data-ttu-id="7e2f9-177">PerSession</span><span class="sxs-lookup"><span data-stu-id="7e2f9-177">PerSession</span></span>|<span data-ttu-id="7e2f9-178">-会话通道的行为：会话和 <xref:System.ServiceModel.InstanceContext> 每个通道。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-178">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each channel.</span></span><br /><span data-ttu-id="7e2f9-179">-无会话通道的行为：将引发异常。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-179">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="7e2f9-180">-会话通道的行为：会话和 <xref:System.ServiceModel.InstanceContext> 每个通道。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-180">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each channel.</span></span><br /><span data-ttu-id="7e2f9-181">-无会话通道的行为： <xref:System.ServiceModel.InstanceContext> 每个调用的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-181">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|<span data-ttu-id="7e2f9-182">-会话通道的行为：将引发异常。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-182">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="7e2f9-183">-无会话通道的行为： <xref:System.ServiceModel.InstanceContext> 每个调用的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-183">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|  
|<span data-ttu-id="7e2f9-184">Single</span><span class="sxs-lookup"><span data-stu-id="7e2f9-184">Single</span></span>|<span data-ttu-id="7e2f9-185">-会话通道的行为：一个会话，一个 <xref:System.ServiceModel.InstanceContext> 用于所有调用。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-185">-   Behavior with sessionful channel: A session and one <xref:System.ServiceModel.InstanceContext> for all calls.</span></span><br /><span data-ttu-id="7e2f9-186">-无会话通道的行为：将引发异常。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-186">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="7e2f9-187">-会话通道的行为：会话以及 <xref:System.ServiceModel.InstanceContext> 创建的或用户指定的单一实例。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-187">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for the created or user-specified singleton.</span></span><br /><span data-ttu-id="7e2f9-188">-无会话通道的行为： <xref:System.ServiceModel.InstanceContext> 用于创建的或用户指定的单一实例的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-188">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for the created or user-specified singleton.</span></span>|<span data-ttu-id="7e2f9-189">-会话通道的行为：将引发异常。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-189">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="7e2f9-190">-无会话通道的行为： <xref:System.ServiceModel.InstanceContext> 用于每个已创建的单一实例或用户指定的单一实例的。</span><span class="sxs-lookup"><span data-stu-id="7e2f9-190">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each created singleton or for the user-specified singleton.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="7e2f9-191">请参阅</span><span class="sxs-lookup"><span data-stu-id="7e2f9-191">See also</span></span>

- [<span data-ttu-id="7e2f9-192">使用会话</span><span class="sxs-lookup"><span data-stu-id="7e2f9-192">Using Sessions</span></span>](../using-sessions.md)
- [<span data-ttu-id="7e2f9-193">如何：创建要求会话的服务</span><span class="sxs-lookup"><span data-stu-id="7e2f9-193">How to: Create a Service That Requires Sessions</span></span>](how-to-create-a-service-that-requires-sessions.md)
- [<span data-ttu-id="7e2f9-194">如何：控制服务实例化</span><span class="sxs-lookup"><span data-stu-id="7e2f9-194">How to: Control Service Instancing</span></span>](how-to-control-service-instancing.md)
- [<span data-ttu-id="7e2f9-195">并发</span><span class="sxs-lookup"><span data-stu-id="7e2f9-195">Concurrency</span></span>](../samples/concurrency.md)
- [<span data-ttu-id="7e2f9-196">实例化</span><span class="sxs-lookup"><span data-stu-id="7e2f9-196">Instancing</span></span>](../samples/instancing.md)
- [<span data-ttu-id="7e2f9-197">会话</span><span class="sxs-lookup"><span data-stu-id="7e2f9-197">Session</span></span>](../samples/session.md)
